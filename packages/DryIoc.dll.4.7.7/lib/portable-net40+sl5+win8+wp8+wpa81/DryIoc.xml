<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DryIoc</name>
    </assembly>
    <members>
        <member name="T:DryIoc.Container">
            <summary>Inversion of control container</summary>
        </member>
        <member name="M:DryIoc.Container.#ctor">
            <summary>Creates new container with default rules <see cref="F:DryIoc.Rules.Default"/>.</summary>
        </member>
        <member name="M:DryIoc.Container.#ctor(DryIoc.Rules,DryIoc.IScopeContext)">
            <summary>Creates new container, optionally providing <see cref="P:DryIoc.Container.Rules"/> to modify default container behavior.</summary>
            <param name="rules">(optional) Rules to modify container default resolution behavior.
            If not specified, then <see cref="F:DryIoc.Rules.Default"/> will be used.</param>
            <param name="scopeContext">(optional) Scope context to use for scoped reuse.</param>
        </member>
        <member name="M:DryIoc.Container.#ctor(System.Func{DryIoc.Rules,DryIoc.Rules},DryIoc.IScopeContext)">
            <summary>Creates new container with configured rules.</summary>
            <param name="configure">Allows to modify <see cref="F:DryIoc.Rules.Default"/> rules.</param>
            <param name="scopeContext">(optional) Scope context to use for <see cref="F:DryIoc.Reuse.InCurrentScope"/>.</param>
        </member>
        <member name="M:DryIoc.Container.NewSingletonScope">
            <summary>Helper to create singleton scope</summary>
        </member>
        <member name="M:DryIoc.Container.ToString">
            <summary>Pretty prints the container info including the open scope details if any.</summary> 
        </member>
        <member name="M:DryIoc.Container.Dispose">
            <summary>Dispose either open scope, or container with singletons, if no scope opened.</summary>
        </member>
        <member name="T:DryIoc.Container.ResolveManyResult">
            <summary>Identifies the service when resolving collection</summary>
        </member>
        <member name="F:DryIoc.Container.ResolveManyResult.FactoryDelegate">
            <summary>Factory, the required part</summary>
        </member>
        <member name="F:DryIoc.Container.ResolveManyResult.ServiceKey">
            <summary>Optional key</summary>
        </member>
        <member name="F:DryIoc.Container.ResolveManyResult.RequiredServiceType">
            <summary>Optional required service type, can be an open-generic type.</summary>
        </member>
        <member name="M:DryIoc.Container.ResolveManyResult.Of(DryIoc.FactoryDelegate,System.Object,System.Type)">
            <summary>Constructs the struct.</summary>
        </member>
        <member name="M:DryIoc.Container.ResolveCompileTimeGeneratedOrDefault(System.Type)">
            <summary>Directly uses generated factories to resolve service. Or returns the default if service does not have generated factory.</summary>
        </member>
        <member name="M:DryIoc.Container.ResolveCompileTimeGeneratedOrDefault(System.Type,System.Object)">
            <summary>Directly uses generated factories to resolve service. Or returns the default if service does not have generated factory.</summary>
        </member>
        <member name="M:DryIoc.Container.ResolveManyCompileTimeGeneratedOrEmpty(System.Type)">
            <summary>Resolves many generated only services. Ignores runtime registrations.</summary>
        </member>
        <member name="M:DryIoc.Container.GetServiceRegistrations">
            <summary>Returns all registered service factories with their Type and optional Key.</summary>
            <remarks>Decorator and Wrapper types are not included.</remarks>
        </member>
        <member name="M:DryIoc.Container.GetRegisteredFactories(System.Type,System.Object,DryIoc.FactoryType)">
            <summary>Searches for registered factories by type, and key (if specified),
            and by factory type (by default uses <see cref="F:DryIoc.FactoryType.Service"/>).
            May return empty, 1 or multiple factories.</summary>
        </member>
        <member name="M:DryIoc.Container.Register(DryIoc.Factory,System.Type,System.Object,System.Nullable{DryIoc.IfAlreadyRegistered},System.Boolean)">
            <summary>Stores factory into container using <paramref name="serviceType"/> and <paramref name="serviceKey"/> as key
            for later lookup.</summary>
            <param name="factory">Any subtypes of <see cref="T:DryIoc.Factory"/>.</param>
            <param name="serviceType">Type of service to resolve later.</param>
            <param name="serviceKey">(optional) Service key of any type with <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>
            implemented.</param>
            <param name="ifAlreadyRegistered">(optional) Says how to handle existing registration with the same
            <paramref name="serviceType"/> and <paramref name="serviceKey"/>.</param>
            <param name="isStaticallyChecked">Confirms that service and implementation types are statically checked by compiler.</param>
            <returns>True if factory was added to registry, false otherwise.
            False may be in case of <see cref="F:DryIoc.IfAlreadyRegistered.Keep"/> setting and already existing factory.</returns>
        </member>
        <member name="M:DryIoc.Container.IsRegistered(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.Unregister(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.Container.Parent">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.Container.Root">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.Container.SingletonScope">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.Container.ScopeContext">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.Container.CurrentScope">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.WithCurrentScope(DryIoc.IScope)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.UseInstance(System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            [Obsolete("Please use `RegisterInstance` or `Use` method instead")]
        </member>
        <member name="M:DryIoc.Container.Use(System.Type,DryIoc.FactoryDelegate)">
            Adding the factory directly to scope for resolution 
        </member>
        <member name="P:DryIoc.Container.Rules">
            <summary>The rules object defines policies per container for registration and resolution.</summary>
        </member>
        <member name="P:DryIoc.Container.OwnCurrentScope">
            <summary>Represents scope bound to container itself, and not the ambient (context) thing.</summary>
        </member>
        <member name="P:DryIoc.Container.IsDisposed">
            <summary>Indicates that container is disposed.</summary>
        </member>
        <member name="M:DryIoc.Container.With(DryIoc.Rules,DryIoc.IScopeContext,DryIoc.RegistrySharing,DryIoc.IScope)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.With(DryIoc.IResolverContext,DryIoc.Rules,DryIoc.IScopeContext,DryIoc.RegistrySharing,DryIoc.IScope,DryIoc.IScope)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.With(DryIoc.IResolverContext,DryIoc.Rules,DryIoc.IScopeContext,DryIoc.RegistrySharing,DryIoc.IScope,DryIoc.IScope,System.Nullable{DryIoc.IsRegistryChangePermitted})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.WithNoMoreRegistrationAllowed(System.Boolean)">
            <summary>Produces new container which prevents any further registrations.</summary>
            <param name="ignoreInsteadOfThrow">(optional) Controls what to do with the next registration: ignore or throw exception. Throws exception by default.</param>
        </member>
        <member name="M:DryIoc.Container.ClearCache(System.Type,System.Nullable{DryIoc.FactoryType},System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.GetConstantExpression(System.Object,System.Type,System.Boolean)">
            <summary>Converts known item into literal expression or wraps it in a constant expression.</summary>
        </member>
        <member name="M:DryIoc.Container.InstanceFactory.UseInterpretation(DryIoc.Request)">
            Switched off until I (or someone) will figure it out.
        </member>
        <member name="M:DryIoc.Container.InstanceFactory.GetDelegateOrDefault(DryIoc.Request)">
            Tries to return instance directly from scope or singleton, and fallbacks to expression for decorator.
        </member>
        <member name="M:DryIoc.Container.InstanceFactory.GetExpressionOrDefault(DryIoc.Request)">
            <summary>Called for Injection as dependency.</summary>
        </member>
        <member name="F:DryIoc.Container.Registry.FactoryExpressionCache">
            <summary>The int key is the `FactoryID`</summary>
        </member>
        <member name="T:DryIoc.OpenGenericTypeKey">
            Special service key with info about open-generic service type
        </member>
        <member name="F:DryIoc.OpenGenericTypeKey.RequiredServiceType">
            <summary>Open-generic required service-type</summary>
        </member>
        <member name="F:DryIoc.OpenGenericTypeKey.ServiceKey">
            <summary>Optional key</summary>
        </member>
        <member name="M:DryIoc.OpenGenericTypeKey.#ctor(System.Type,System.Object)">
            <summary>Constructs the thing</summary>
        </member>
        <member name="M:DryIoc.OpenGenericTypeKey.ToString">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.OpenGenericTypeKey.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.OpenGenericTypeKey.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.OpenGenericTypeKey.ToExpression(System.Func{System.Object,System.Linq.Expressions.Expression})">
            <inheritdoc />
        </member>
        <member name="T:DryIoc.HiddenDisposable">
            <summary>Hides/wraps object with disposable interface.</summary> 
        </member>
        <member name="F:DryIoc.HiddenDisposable.Value">
            <summary>Wrapped value</summary>
        </member>
        <member name="M:DryIoc.HiddenDisposable.#ctor(System.Object)">
            <summary>Wraps the value</summary>
        </member>
        <member name="T:DryIoc.Interpreter">
            Interpreter of expression - where possible uses knowledge of DryIoc internals to avoid reflection
        </member>
        <member name="M:DryIoc.Interpreter.TryInterpretAndUnwrapContainerException(DryIoc.IResolverContext,System.Linq.Expressions.Expression,System.Boolean,System.Object@)">
            Calls `TryInterpret` inside try-catch and unwraps/re-throws `ContainerException` from the reflection `TargetInvocationException`
        </member>
        <member name="T:DryIoc.Interpreter.ParentLambdaArgs">
            <summary>Stores parent lambda params and args</summary>
        </member>
        <member name="F:DryIoc.Interpreter.ParentLambdaArgs.ParentWithArgs">
            <summary> Parent or the `null` for the root </summary>
        </member>
        <member name="F:DryIoc.Interpreter.ParentLambdaArgs.ParamExprs">
            <summary> Params </summary>
        </member>
        <member name="F:DryIoc.Interpreter.ParentLambdaArgs.ParamValues">
            <summary> Args </summary>
        </member>
        <member name="M:DryIoc.Interpreter.ParentLambdaArgs.#ctor(DryIoc.Interpreter.ParentLambdaArgs,System.Object,System.Object)">
            <summary>Constructs with parent parent or `null` for the root</summary>
        </member>
        <member name="M:DryIoc.Interpreter.TryInterpret(DryIoc.IResolverContext,System.Linq.Expressions.Expression,System.Object,System.Object,DryIoc.Interpreter.ParentLambdaArgs,System.Boolean,System.Object@)">
            <summary>Interprets passed expression</summary>
        </member>
        <member name="T:DryIoc.FactoryDelegateCompiler">
            <summary>Compiles expression to factory delegate.</summary>
        </member>
        <member name="F:DryIoc.FactoryDelegateCompiler.ResolverContextParamExpr">
            <summary>Resolver context parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="F:DryIoc.FactoryDelegateCompiler.FactoryDelegateParamTypes">
            [Obsolete("Not used anymore")]
        </member>
        <member name="F:DryIoc.FactoryDelegateCompiler.FactoryDelegateParamExprs">
            Optimization: singleton array with the parameter expression of IResolverContext
        </member>
        <member name="M:DryIoc.FactoryDelegateCompiler.NormalizeExpression(System.Linq.Expressions.Expression)">
            Strips the unnecessary or adds the necessary cast to expression return result
        </member>
        <member name="M:DryIoc.FactoryDelegateCompiler.WrapInFactoryExpression(System.Linq.Expressions.Expression)">
            <summary>Wraps service creation expression (body) into <see cref="T:DryIoc.FactoryDelegate"/> and returns result lambda expression.</summary>
        </member>
        <member name="M:DryIoc.FactoryDelegateCompiler.CompileToFactoryDelegate(System.Linq.Expressions.Expression,System.Boolean,System.Boolean)">
            <summary>First wraps the input service expression into lambda expression and
            then compiles lambda expression to actual <see cref="T:DryIoc.FactoryDelegate"/> used for service resolution.</summary>
        </member>
        <member name="M:DryIoc.FactoryDelegateCompiler.CompileToFactoryDelegate(System.Linq.Expressions.Expression,System.Type,System.Type,System.Boolean,System.Boolean)">
            <summary>Compiles lambda expression to actual `FactoryDelegate` wrapper.</summary>
        </member>
        <member name="M:DryIoc.FactoryDelegateCompiler.CompileToFactoryDelegate(System.Linq.Expressions.Expression,System.Boolean)">
            [Obsolete("Use the version with `preferInterpretation` parameter instead")]
        </member>
        <member name="M:DryIoc.FactoryDelegateCompiler.ToExpression(System.Linq.Expressions.Expression)">
            <summary>Restores the expression from LightExpression, or returns itself if already an Expression.</summary>
        </member>
        <member name="T:DryIoc.ContainerTools">
            <summary>Container extended features.</summary>
        </member>
        <member name="F:DryIoc.ContainerTools.FacadeKey">
            <summary>The default key for services registered into container created by <see cref="M:DryIoc.ContainerTools.CreateFacade(DryIoc.IContainer,System.String)"/></summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithFacadeRules(DryIoc.Rules,System.String)">
            <summary>Uses the provided or the default <see cref="F:DryIoc.ContainerTools.FacadeKey" /> to tweak the rules
            to use with the `CreateFacade` methods</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.CreateFacade(DryIoc.IContainer,System.String)">
            <summary>Allows to register new specially keyed services which will facade the same default service,
            registered earlier. May be used to "override" registrations when testing the container.
            Facade will clone the source container singleton and open scope (if any) so
            that you may safely disposing the facade without disposing the source container scopes.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.CreateChild(DryIoc.IContainer,System.Nullable{DryIoc.IfAlreadyRegistered},DryIoc.Rules,System.Boolean)">
            <summary>The "child" container detached from the parent:
            Child creation has O(1) cost - it is cheap thanks to the fast immutable collections cloning.
            Child has all parent registrations copied, then the registrations added or removed in the child are not affecting the parent.
            By default child will use the parent <see cref="T:DryIoc.IfAlreadyRegistered"/> policy - you may specify `IfAlreadyRegistered.Replace` to "shadow" the parent registrations
            Child has an access to the scoped services and singletons already created by parent.
            Child can be disposed without affecting the parent, disposing the child will dispose only the scoped services and singletons created in the child and not in the parent (can be opt-out)</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.With(DryIoc.IContainer,System.Func{DryIoc.Rules,DryIoc.Rules},DryIoc.IScopeContext)">
            <summary>Shares all of container state except the cache and the new rules.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithExpressionGeneration(DryIoc.IContainer,System.Boolean)">
            <summary>Prepares container for expression generation.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithoutCache(DryIoc.IContainer)">
            <summary>Returns new container with all expression, delegate, items cache removed/reset.
            But it will preserve resolved services in Singleton/Current scope.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithoutSingletonsAndCache(DryIoc.IContainer)">
            <summary>Creates new container with state shared with original, except for the singletons and cache.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithRegistrationsCopy(DryIoc.IContainer,System.Boolean)">
            <summary>Shares the setup with original container but copies the registrations, so the new registrations
            won't be visible in original. Registrations include decorators and wrappers as well.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithRegistrationsCopy(DryIoc.IContainer,DryIoc.IsRegistryChangePermitted,System.Boolean)">
            <summary>Shares the setup with original container but copies the registrations, so the new registrations
            won't be visible in original. Registrations include decorators and wrappers as well.
            You may control <see cref="T:DryIoc.IsRegistryChangePermitted" /> behavior and opt-in for the keeping or cloning the cache.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.InjectPropertiesAndFields``1(DryIoc.IResolverContext,``0)">
            <summary>For given instance resolves and sets properties and fields.
            It respects <see cref="P:DryIoc.Rules.PropertiesAndFields"/> rules set per container,
            or if rules are not set it uses <see cref="F:DryIoc.PropertiesAndFields.Auto"/>.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.InjectPropertiesAndFields``1(DryIoc.IResolverContext,``0,System.String[])">
            <summary>For given instance resolves and sets properties and fields. You may specify what 
            properties and fields.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.New(DryIoc.IContainer,System.Type,DryIoc.Setup,DryIoc.Made,DryIoc.RegistrySharing)">
            <summary>Creates service using container for injecting parameters without registering anything in <paramref name="container"/> if the TYPE is not registered yet. 
            The note is that container will share the singletons though.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.New(DryIoc.IContainer,System.Type,DryIoc.Made,DryIoc.RegistrySharing)">
            <summary>Creates service using container for injecting parameters without registering anything in <paramref name="container"/>.</summary>
            <param name="container">Container to use for type creation and injecting its dependencies.</param>
            <param name="concreteType">Type to instantiate. Wrappers (Func, Lazy, etc.) is also supported.</param>
            <param name="made">(optional) Injection rules to select constructor/factory method, inject parameters, 
            properties and fields.</param>
            <param name="registrySharing">The default is <see cref="F:DryIoc.RegistrySharing.CloneButKeepCache"/></param>
            <returns>Object instantiated by constructor or object returned by factory method.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.New``1(DryIoc.IContainer,DryIoc.Made,DryIoc.RegistrySharing)">
            <summary>Creates service using container for injecting parameters without registering anything in <paramref name="container"/>.</summary>
            <typeparam name="T">Type to instantiate.</typeparam>
            <param name="container">Container to use for type creation and injecting its dependencies.</param>
            <param name="made">(optional) Injection rules to select constructor/factory method, inject parameters, properties and fields.</param>
            <param name="registrySharing">The default is <see cref="F:DryIoc.RegistrySharing.CloneButKeepCache"/></param>
            <returns>Object instantiated by constructor or object returned by factory method.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.New``1(DryIoc.IContainer,DryIoc.Made.TypedMade{``0},DryIoc.RegistrySharing)">
            <summary>Creates service given strongly-typed creation expression.
            Can be used to invoke arbitrary method returning some value with injecting its parameters from container.</summary>
            <typeparam name="T">Method or constructor result type.</typeparam>
            <param name="container">Container to use for injecting dependencies.</param>
            <param name="made">Creation expression.</param>
            <param name="registrySharing">The default is <see cref="F:DryIoc.RegistrySharing.CloneButKeepCache"/></param>
            <returns>Created result.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.RegisterMapping(DryIoc.IContainer,System.Type,System.Type,System.Object,System.Object)">
            <summary>Registers new service type with factory for registered service type.
            Throw if no such registered service type in container.</summary>
            <param name="container">Container</param> <param name="serviceType">New service type.</param>
            <param name="registeredServiceType">Existing registered service type.</param>
            <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
        </member>
        <member name="M:DryIoc.ContainerTools.RegisterMapping``2(DryIoc.IContainer,System.Object,System.Object)">
            <summary>Registers new service type with factory for registered service type.
            Throw if no such registered service type in container.</summary>
            <param name="container">Container</param>
            <typeparam name="TService">New service type.</typeparam>
            <typeparam name="TRegisteredService">Existing registered service type.</typeparam>
            <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
        </member>
        <member name="M:DryIoc.ContainerTools.RegisterPlaceholder(DryIoc.IContainer,System.Type,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Forwards to <see cref="M:DryIoc.Registrator.RegisterPlaceholder(DryIoc.IRegistrator,System.Type,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)"/>.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.RegisterPlaceholder``1(DryIoc.IContainer,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Register a service without implementation which can be provided later in terms
            of normal registration with IfAlreadyRegistered.Replace parameter.
            When the implementation is still not provided when the placeholder service is accessed,
            then the exception will be thrown.
            This feature allows you to postpone decision on implementation until it is later known.</summary>
            <remarks>Internally the empty factory is registered with the setup asResolutionCall set to true.
            That means, instead of placing service instance into graph expression we put here redirecting call to
            container Resolve.</remarks>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackResolution(DryIoc.IContainer,System.Collections.Generic.IEnumerable{System.Type},System.Func{DryIoc.IReuse,DryIoc.Request,DryIoc.IReuse},System.Func{DryIoc.Request,System.Boolean})">
            Obsolete: please use WithAutoFallbackDynamicRegistration
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackResolution(DryIoc.IContainer,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Func{DryIoc.IReuse,DryIoc.Request,DryIoc.IReuse},System.Func{DryIoc.Request,System.Boolean})">
            Obsolete: please use WithAutoFallbackDynamicRegistration
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Func{System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Type}},System.Func{System.Type,DryIoc.Factory})">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath it uses the `WithDynamicRegistrations`.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Type[])">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath it uses the `WithDynamicRegistrations`.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,DryIoc.IReuse,System.Type[])">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath it uses the `WithDynamicRegistrations`.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,DryIoc.IReuse,DryIoc.Setup,System.Type[])">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath it uses the `WithDynamicRegistrations`.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Func{System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Reflection.Assembly}},System.Func{System.Type,DryIoc.Factory})">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath it uses the `WithDynamicRegistrations`.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Reflection.Assembly[])">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath it uses the `WithDynamicRegistrations`.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath it uses the `WithDynamicRegistrations`.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithDependencies(DryIoc.IContainer,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates new container with provided parameters and properties
            to pass the custom dependency values for injection. The old parameters and properties are overridden,
            but not replaced.</summary>
            <param name="container">Container to work with.</param>
            <param name="parameters">(optional) Parameters specification, can be used to proved custom values.</param>
            <param name="propertiesAndFields">(optional) Properties and fields specification, can be used to proved custom values.</param>
            <returns>New container with adjusted rules.</returns>
            <example><code lang="cs"><![CDATA[
                var c = container.WithDependencies(Parameters.Of.Type<string>(_ => "Nya!"));
                var a = c.Resolve<A>(); // where A accepts string parameter in constructor
                Assert.AreEqual("Nya!", a.Message)
            ]]></code></example>
        </member>
        <member name="T:DryIoc.ContainerTools.GeneratedExpressions">
            <summary>Result of GenerateResolutionExpressions methods</summary>
        </member>
        <member name="F:DryIoc.ContainerTools.GeneratedExpressions.Roots">
            <summary>Resolutions roots</summary>
        </member>
        <member name="F:DryIoc.ContainerTools.GeneratedExpressions.ResolveDependencies">
            <summary>Dependency of Resolve calls</summary>
        </member>
        <member name="F:DryIoc.ContainerTools.GeneratedExpressions.Errors">
            <summary>Errors</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.GenerateResolutionExpressions(DryIoc.IContainer,System.Func{System.Collections.Generic.IEnumerable{DryIoc.ServiceRegistrationInfo},System.Collections.Generic.IEnumerable{DryIoc.ServiceInfo}},System.Boolean)">
            <summary>Generates expressions for specified roots and their "Resolve-call" dependencies.
            Wraps exceptions into errors. The method does not create any actual services.
            You may use Factory <see cref="P:DryIoc.Setup.AsResolutionRoot"/>.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.GenerateResolutionExpressions(DryIoc.IContainer,System.Func{DryIoc.ServiceRegistrationInfo,System.Boolean})">
            <summary>Generates expressions for provided root services</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.GenerateResolutionExpressions(DryIoc.IContainer,DryIoc.ServiceInfo[])">
            <summary>Generates expressions for provided root services</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.DefaultValidateCondition(DryIoc.ServiceRegistrationInfo)">
            <summary>Excluding open-generic registrations, cause you need to provide type arguments to actually create these types.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.Validate(DryIoc.IContainer,System.Func{DryIoc.ServiceRegistrationInfo,System.Boolean})">
            <summary>Helps to find potential problems in service registration setup. Method tries to resolve the specified registrations, collects exceptions, 
            and returns them to user. Does not create any actual service objects. You must specify <paramref name="condition"/> to define your resolution roots,
            otherwise container will try to resolve all registrations, which usually is not realistic case to validate.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.ValidateAndThrow(DryIoc.IContainer,System.Func{DryIoc.ServiceRegistrationInfo,System.Boolean})">
            <summary>Same as the Validate with the same parameters but throws the exception with all collected errors</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.Validate(DryIoc.IContainer,DryIoc.ServiceInfo[])">
            <summary>Helps to find potential problems when resolving the <paramref name="roots"/>.
            Method will collect the exceptions when resolving or injecting the specific root. Does not create any actual service objects.
            You must specify <paramref name="roots"/> to define your resolution roots, otherwise container will try to resolve all registrations, 
            which usually is not realistic case to validate.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.ValidateAndThrow(DryIoc.IContainer,DryIoc.ServiceInfo[])">
            <summary>Same as the Validate with the same parameters but throws the exception with all collected errors</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.Validate(DryIoc.IContainer,System.Type[])">
            <summary>Helps to find potential problems in service registration setup by trying to resolve the <paramref name="serviceTypes"/> and 
            returning the found errors. This method does not throw.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.ValidateAndThrow(DryIoc.IContainer,System.Type[])">
            <summary>Same as the Validate with the same parameters but throws the exception with all collected errors</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.GetRequestExpression(DryIoc.IContainer,DryIoc.Request,DryIoc.RequestFlags)">
            <summary>Re-constructs the whole request chain as request creation expression.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.ClearCache``1(DryIoc.IContainer,System.Nullable{DryIoc.FactoryType},System.Object)">
            <summary>Clears delegate and expression cache for specified <typeparamref name="T"/>.
            But does not clear instances of already resolved/created singletons and scoped services!</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.ClearCache(DryIoc.IContainer,System.Type,System.Nullable{DryIoc.FactoryType},System.Object)">
            <summary>Clears delegate and expression cache for specified service.
            But does not clear instances of already resolved/created singletons and scoped services!</summary>
        </member>
        <member name="T:DryIoc.IConvertibleToExpression">
            <summary>Interface used to convert reuse instance to expression.</summary>
        </member>
        <member name="M:DryIoc.IConvertibleToExpression.ToExpression(System.Func{System.Object,System.Linq.Expressions.Expression})">
            <summary>Returns expression representation without closure.
            Use <paramref name="fallbackConverter"/> to converting the sub-items, constants to container.</summary>
        </member>
        <member name="T:DryIoc.DefaultKey">
            <summary>Used to represent multiple default service keys.
            Exposes <see cref="F:DryIoc.DefaultKey.RegistrationOrder"/> to determine order of service added.</summary>
        </member>
        <member name="F:DryIoc.DefaultKey.Value">
            <summary>Default value.</summary>
        </member>
        <member name="F:DryIoc.DefaultKey.RegistrationOrder">
            <summary>Allows to determine service registration order.</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.Of(System.Int32)">
            <summary>Returns the default key with specified registration order.</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.ToExpression(System.Func{System.Object,System.Linq.Expressions.Expression})">
            <summary>Converts to expression</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.Next">
            <summary>Returns next default key with increased <see cref="F:DryIoc.DefaultKey.RegistrationOrder"/>.</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.Equals(System.Object)">
            <summary>Compares keys based on registration order. The null (represents default) key is considered equal.</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.GetHashCode">
            <summary>Returns registration order as hash.</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.ToString">
            <summary>Prints registration order to string.</summary>
        </member>
        <member name="T:DryIoc.DefaultDynamicKey">
            <summary>Represents default key for dynamic registrations</summary>
        </member>
        <member name="F:DryIoc.DefaultDynamicKey.Value">
            <summary>Default value.</summary>
        </member>
        <member name="F:DryIoc.DefaultDynamicKey.RegistrationOrder">
            <summary>Associated ID.</summary>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.Of(System.Int32)">
            <summary>Returns dynamic key with specified ID.</summary>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.ToExpression(System.Func{System.Object,System.Linq.Expressions.Expression})">
            <summary>Converts to expression</summary>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.Next">
            <summary>Returns next dynamic key with increased <see cref="F:DryIoc.DefaultDynamicKey.RegistrationOrder"/>.</summary> 
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.Equals(System.Object)">
            <summary>Compares key's IDs. The null (default) key is considered equal!</summary>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.GetHashCode">
            <summary>Returns key index as hash.</summary>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.ToString">
            <summary>Prints registration order to string.</summary>
        </member>
        <member name="T:DryIoc.IResolverContext">
            <summary>Extends IResolver to provide an access to scope hierarchy.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.IsDisposed">
            <summary>True if container is disposed.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.Parent">
            <summary>Parent context of the scoped context.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.Root">
            <summary>The root context of the scoped context.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.SingletonScope">
            <summary>Singleton scope, always associated with root scope.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.ScopeContext">
            <summary>Optional ambient scope context.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.CurrentScope">
            <summary>Current opened scope. May return the current scope from <see cref="P:DryIoc.IResolverContext.ScopeContext"/> if context is not null.</summary>
        </member>
        <member name="M:DryIoc.IResolverContext.WithCurrentScope(DryIoc.IScope)">
            Creates the resolver context with specified current Container-OWN scope 
        </member>
        <member name="M:DryIoc.IResolverContext.UseInstance(System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            Put instance into the current scope or singletons.
        </member>
        <member name="M:DryIoc.IResolverContext.Use(System.Type,DryIoc.FactoryDelegate)">
            Puts instance created via the passed factory on demand into the current or singleton scope
        </member>
        <member name="M:DryIoc.IResolverContext.InjectPropertiesAndFields(System.Object,System.String[])">
            <summary>For given instance resolves and sets properties and fields.</summary>
        </member>
        <member name="T:DryIoc.ResolverContext">
            <summary>Provides a usable abstractions for <see cref="T:DryIoc.IResolverContext"/></summary>
        </member>
        <member name="M:DryIoc.ResolverContext.RootOrSelf(DryIoc.IResolverContext)">
            <summary>Just a sugar that allow to get root or self container.</summary>
        </member>
        <member name="M:DryIoc.ResolverContext.GetRootOrSelfExpr(DryIoc.Request)">
            <summary>Returns root or self resolver based on request.</summary>
        </member>
        <member name="F:DryIoc.ResolverContext.ParentExpr">
            <summary>Resolver context parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="F:DryIoc.ResolverContext.RootOrSelfExpr">
            <summary>Resolver parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="F:DryIoc.ResolverContext.SingletonScopeExpr">
            <summary>Resolver parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="F:DryIoc.ResolverContext.CurrentScopeExpr">
            <summary>Access to scopes in FactoryDelegate.</summary>
        </member>
        <member name="M:DryIoc.ResolverContext.IsScoped(DryIoc.IResolverContext)">
            Indicates that context is scoped - that's is only possible if container is not the Root one and has a Parent context
        </member>
        <member name="M:DryIoc.ResolverContext.GetCurrentScope(DryIoc.IResolverContext,System.Boolean)">
            Provides access to the current scope - may return `null` if ambient scope context has it scope changed in-between 
        </member>
        <member name="M:DryIoc.ResolverContext.GetNamedScope(DryIoc.IResolverContext,System.Object,System.Boolean)">
            <summary>Gets current scope matching the <paramref name="name"/></summary>
        </member>
        <member name="M:DryIoc.ResolverContext.OpenScope(DryIoc.IResolverContext,System.Object,System.Boolean)">
            <summary>Opens scope with optional name and optional tracking of new scope in a parent scope.</summary>
            <param name="r">Parent context to use.</param>
            <param name="name">(optional)</param>
            <param name="trackInParent">(optional) Instructs to additionally store the opened scope in parent, 
            so it will be disposed when parent is disposed. If no parent scope is available the scope will be tracked by Singleton scope.
            Used to dispose a resolution scope.</param>
            <returns>Scoped resolver context.</returns>
            <example><code lang="cs"><![CDATA[
            using (var scope = container.OpenScope())
            {
                var handler = scope.Resolve<IHandler>();
                handler.Handle(data);
            }
            ]]></code></example>
        </member>
        <member name="M:DryIoc.ResolverContext.TrackDisposable``1(DryIoc.IResolverContext,``0)">
            <summary>A bit if sugar to track disposable in the current scope or in the singleton scope as a fallback</summary>
        </member>
        <member name="T:DryIoc.FactoryDelegate">
            <summary>The result delegate generated by DryIoc for service creation.</summary>
        </member>
        <member name="T:DryIoc.FactoryDelegate`1">
            <summary>The stronly typed delegate for service creation registered as a Wrapper.</summary>
        </member>
        <member name="T:DryIoc.WrappersSupport">
            <summary>Adds to Container support for:
            <list type="bullet">
            <item>Open-generic services</item>
            <item>Service generics wrappers and arrays using <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/> extension point.
            Supported wrappers include: Func of <see cref="F:DryIoc.WrappersSupport.FuncTypes"/>, Lazy, Many, IEnumerable, arrays, Meta, KeyValuePair, DebugExpression.
            All wrapper factories are added into collection of <see cref="F:DryIoc.WrappersSupport.Wrappers"/>.
            unregistered resolution rule.</item>
            </list></summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.FuncTypes">
            <summary>Supported Func types.</summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.ActionTypes">
            <summary>Supported Action types. Yeah, action I can resolve or inject void returning method as action.</summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.SupportedCollectionTypes">
            <summary>Supported open-generic collection types - all the interfaces implemented by array.</summary>
        </member>
        <member name="M:DryIoc.WrappersSupport.IsFunc(System.Type)">
            <summary>Returns true if type is supported <see cref="F:DryIoc.WrappersSupport.FuncTypes"/>, and false otherwise.</summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.Wrappers">
            <summary>Registered wrappers by their concrete or generic definition service type.</summary>
        </member>
        <member name="M:DryIoc.WrappersSupport.GetLazyExpressionOrDefault(DryIoc.Request,System.Boolean)">
            <summary>Gets the expression for <see cref="T:System.Lazy`1"/> wrapper.</summary>
            <param name="request">The resolution request.</param>
            <param name="nullWrapperForUnresolvedService">if set to <c>true</c> then check for service registration before creating resolution expression.</param>
            <returns>Expression: <c><![CDATA[r => new Lazy<TService>(() => r.Resolve{TService}(key, ifUnresolved, requiredType))]]></c></returns>
        </member>
        <member name="M:DryIoc.WrappersSupport.GetMetaExpressionOrDefault(DryIoc.Request)">
            <summary>Discovers and combines service with its setup metadata.
            Works with any generic type with first Type arg - Service type and second Type arg - Metadata type,
            and constructor with Service and Metadata arguments respectively.
            - if service key is not specified in request then method will search for all
            registered factories with the same metadata type ignoring keys.
            - if metadata is IDictionary{string, object},
             then the First value matching the TMetadata type will be returned.</summary>
        </member>
        <member name="T:DryIoc.DynamicRegistration">
            <summary>Represents info required for dynamic registration: service key, factory,
            and <see cref="F:DryIoc.DynamicRegistration.IfAlreadyRegistered"/> option how to combine dynamic with normal registrations.</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistration.Factory">
            <summary>Factory</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistration.IfAlreadyRegistered">
            <summary>Optional: will be <see cref="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed"/> by default.</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistration.ServiceKey">
            <summary>Optional service key: if null the default <see cref="T:DryIoc.DefaultDynamicKey"/> will be used. </summary>
        </member>
        <member name="M:DryIoc.DynamicRegistration.#ctor(DryIoc.Factory,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Constructs the info</summary>
        </member>
        <member name="T:DryIoc.DynamicRegistrationFlags">
            <summary>The options for the single dynamic registration provider.
            The dynamic Wrapper registration is not supported.</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistrationFlags.NoFlags">
            <summary>No flags - to use in `GetDynamicRegistrationProvidersOrDefault`</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistrationFlags.AsFallback">
            <summary>Use as AsFallback only</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistrationFlags.Service">
            <summary>Provider may have the services provided</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistrationFlags.Decorator">
            <summary>Provider may have the decorators provided</summary>
        </member>
        <member name="T:DryIoc.Rules">
            <summary> Defines resolution/registration rules associated with Container instance. They may be different for different containers.</summary>
        </member>
        <member name="F:DryIoc.Rules.Default">
            <summary>Default rules as a staring point.</summary>
        </member>
        <member name="F:DryIoc.Rules.MicrosoftDependencyInjectionRules">
            <summary>The rules implementing the conventions of Microsoft.Extension.DependencyInjection library.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithMicrosoftDependencyInjectionRules">
            <summary>Returns the copy of the rules with the applied conventions of Microsoft.Extension.DependencyInjection library.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithServiceProviderGetServiceShouldThrowIfUnresolved">
            <summary></summary>
        </member>
        <member name="P:DryIoc.Rules.ServiceProviderGetServiceShouldThrowIfUnresolved">
            <summary><see cref="M:DryIoc.Rules.WithServiceProviderGetServiceShouldThrowIfUnresolved"/></summary>
        </member>
        <member name="F:DryIoc.Rules.DefaultDependencyDepthToSplitObjectGraph">
            <summary>Does nothing</summary>
        </member>
        <member name="P:DryIoc.Rules.DependencyDepthToSplitObjectGraph">
            <summary>Does nothing</summary>
        </member>
        <member name="F:DryIoc.Rules.DefaultDependencyCountInLambdaToSplitBigObjectGraph">
            <summary>The default total dependency count - a expression tree node count to split the object graph</summary>
        </member>
        <member name="P:DryIoc.Rules.DependencyCountInLambdaToSplitBigObjectGraph">
             <summary>The total dependency count - the expression tree node count to split the object graph.
             That does not mean the graph can be always split at this number, consider the example graph and
             the dependency count threshold set to 3:
            
             `x = new X(new Y(A, new B(K), new C(new L(), new M())), new Z())`
             
             The tree is resolved from the left to the right in the depth-first order:
             A; then K, B (at this point Y is already has 3 dependencies but is not fully resolved until C is resolved);
             then L, M, C (here Y is fully resolved with 6 dependencies) so we can split it only on 6 dependencies instead of 3.
            
             The split itseft just wraps the node in `Func{T}` delegate making it a separate compilation unit.
             In our example it will be `Func{Y} f = () => new Y(A, new B(K), new C(new L(), new M()))` considering
             that everything is transient.
             </summary>
        </member>
        <member name="M:DryIoc.Rules.WithDependencyDepthToSplitObjectGraph(System.Int32)">
            <summary>Does nothing</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDependencyCountInLambdaToSplitBigObjectGraph(System.Int32)">
            <summary>Sets the <see cref="P:DryIoc.Rules.DependencyCountInLambdaToSplitBigObjectGraph"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutDependencyDepthToSplitObjectGraph">
            <summary>Does nothing</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutDependencyCountInLambdaToSplitBigObjectGraph">
            <summary>Disables the <see cref="P:DryIoc.Rules.DependencyCountInLambdaToSplitBigObjectGraph"/> limitation.</summary>
        </member>
        <member name="P:DryIoc.Rules.FactoryMethod">
            <summary>Shorthand to <see cref="P:DryIoc.Made.FactoryMethod"/></summary>
        </member>
        <member name="P:DryIoc.Rules.Parameters">
            <summary>Shorthand to <see cref="P:DryIoc.Made.Parameters"/></summary>
        </member>
        <member name="P:DryIoc.Rules.PropertiesAndFields">
            <summary>Shorthand to <see cref="P:DryIoc.Made.PropertiesAndFields"/></summary>
        </member>
        <member name="P:DryIoc.Rules.OverrideRegistrationMade">
            <summary>Instructs to override per-registration made settings with these rules settings.</summary>
        </member>
        <member name="M:DryIoc.Rules.TryGetParameterSelector(DryIoc.Made)">
            <summary>Returns the parameter selector based on <see cref="P:DryIoc.Rules.OverrideRegistrationMade"/></summary>
        </member>
        <member name="M:DryIoc.Rules.TryGetPropertiesAndFieldsSelector(DryIoc.Made)">
            <summary>Returns the properties and fields selectorbased on <see cref="P:DryIoc.Rules.OverrideRegistrationMade"/></summary>
        </member>
        <member name="M:DryIoc.Rules.With(DryIoc.FactoryMethodSelector,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Returns new instance of the rules new Made composed out of
            provided factory method, parameters, propertiesAndFields.</summary>
        </member>
        <member name="M:DryIoc.Rules.With(DryIoc.Made,System.Boolean)">
            <summary>Returns new instance of the rules with specified <see cref="T:DryIoc.Made"/>.</summary>
            <param name="made">New Made.Of rules.</param>
            <param name="overrideRegistrationMade">Instructs to override registration level Made.Of</param>
            <returns>New rules.</returns>
        </member>
        <member name="P:DryIoc.Rules.DefaultRegistrationServiceKey">
            <summary>Service key to be used instead on `null` in registration.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDefaultRegistrationServiceKey(System.Object)">
            <summary>Sets the <see cref="P:DryIoc.Rules.DefaultRegistrationServiceKey"/></summary>
        </member>
        <member name="T:DryIoc.Rules.FactorySelectorRule">
            <summary>Defines single factory selector delegate.</summary>
            <param name="request">Provides service request leading to factory selection.</param>
            <param name="factories">Registered factories with corresponding key to select from.</param>
            <returns>Single selected factory, or null if unable to select.</returns>
        </member>
        <member name="P:DryIoc.Rules.FactorySelector">
            <summary>Rules to select single matched factory default and keyed registered factory/factories.
            Selectors applied in specified array order, until first returns not null <see cref="T:DryIoc.Factory"/>.
            Default behavior is to throw on multiple registered default factories, cause it is not obvious what to use.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithFactorySelector(DryIoc.Rules.FactorySelectorRule)">
            <summary>Sets <see cref="P:DryIoc.Rules.FactorySelector"/></summary>
        </member>
        <member name="M:DryIoc.Rules.SelectLastRegisteredFactory">
            <summary>Select last registered factory from the multiple default.</summary>
        </member>
        <member name="M:DryIoc.Rules.SelectFactoryWithTheMinReuseLifespan">
            <summary>Tries to select a single factory based on the minimal reuse life-span ignoring the Transients</summary>
        </member>
        <member name="M:DryIoc.Rules.SelectFactoryWithTheMinReuseLifespanOrLastRegistered">
            <summary>Tries either SelectFactoryWithTheMinReuseLifespan or SelectLastRegisteredFactory</summary>
        </member>
        <member name="M:DryIoc.Rules.SelectKeyedOverDefaultFactory(System.Object)">
            <summary>Prefer specified service key (if found) over default key.
            Help to override default registrations in Open Scope scenarios:
            I may register service with key and resolve it as default in current scope.</summary>
        </member>
        <member name="T:DryIoc.Rules.DynamicRegistrationProvider">
            <summary>Specify the method signature for returning multiple keyed factories.
            This is dynamic analog to the normal Container Registry.</summary>
            <param name="serviceType">Requested service type.</param>
            <param name="serviceKey">(optional) If <c>null</c> will request all factories of <paramref name="serviceType"/></param>
            <returns>Key-Factory pairs.</returns>
        </member>
        <member name="P:DryIoc.Rules.DynamicRegistrationProviders">
            <summary>Providers for resolving multiple not-registered services. Null by default.</summary>
        </member>
        <member name="P:DryIoc.Rules._dynamicRegistrationFlags">
            <summary>The flags per dynamic registration provider</summary>
        </member>
        <member name="M:DryIoc.Rules.HasDynamicRegistrationProvider(DryIoc.DynamicRegistrationFlags,DryIoc.DynamicRegistrationFlags)">
            <summary>Get the specific providers with the specified flags and without the flags or return `null` if nothing found</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDynamicRegistration(DryIoc.Rules.DynamicRegistrationProvider,DryIoc.DynamicRegistrationFlags)">
            <summary>Returns the new rules with the passed dynamic registration rule appended.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.Rules.DynamicRegistrationProvider[])">
            <summary>Returns the new rules with the passed dynamic registration rules appended.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDynamicRegistrationsAsFallback(DryIoc.Rules.DynamicRegistrationProvider[])">
            <summary>Returns the new rules with the passed dynamic registration rules appended. 
            The rules applied only when no normal registrations found!</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.DynamicRegistrationFlags,DryIoc.Rules.DynamicRegistrationProvider[])">
            <summary>Returns the new rules with the passed dynamic registration rules appended. 
            The rules applied only when no normal registrations found!</summary>
        </member>
        <member name="P:DryIoc.Rules.UseDynamicRegistrationsAsFallbackOnly">
            <summary>Obsolete["Instead use <![CDATA[(GetDynamicRegistrationProvidersOrDefault(DynamicRegistrationProviderFlags.UseAsFallback)]]>"]</summary>
        </member>
        <member name="T:DryIoc.Rules.UnknownServiceResolver">
            <summary>Defines delegate to return factory for request not resolved by registered factories or prior rules.
            Applied in specified array order until return not null <see cref="T:DryIoc.Factory"/>.</summary>
        </member>
        <member name="P:DryIoc.Rules.UnknownServiceResolvers">
            <summary>Gets rules for resolving not-registered services. Null by default.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithUnknownServiceResolvers(DryIoc.Rules.UnknownServiceResolver[])">
            <summary>Appends resolver to current unknown service resolvers.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutUnknownServiceResolver(DryIoc.Rules.UnknownServiceResolver)">
            <summary>Removes specified resolver from unknown service resolvers, and returns new Rules.
            If no resolver was found then <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/> will stay the same instance,
            so it could be check for remove success or fail.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithUnknownServiceHandler(System.Action{DryIoc.Request})">
            <summary>Sugar on top of <see cref="M:DryIoc.Rules.WithUnknownServiceResolvers(DryIoc.Rules.UnknownServiceResolver[])"/> to simplify setting the diagnostic action.
            Does not guard you from action throwing an exception. Actually can be used to throw your custom exception
            instead of <see cref="T:DryIoc.ContainerException"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.AutoResolveConcreteTypeRule(System.Func{DryIoc.Request,System.Boolean})">
            <summary>The alternative is ConcreteTypeDynamicRegistrations</summary>
        </member>
        <member name="M:DryIoc.Rules.ConcreteTypeDynamicRegistrations(System.Func{System.Type,System.Object,System.Boolean},DryIoc.IReuse)">
            <summary>Rule to automatically resolves non-registered service type which is: nor interface, nor abstract.
            For constructor selection we are using <see cref="F:DryIoc.FactoryMethod.ConstructorWithResolvableArguments"/>.
            The resolution creates transient services.</summary>
            <param name="condition">(optional) Condition for requested service type and key.</param>
            <param name="reuse">(optional) Reuse for concrete types.</param>
            <returns>New rule.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithConcreteTypeDynamicRegistrations(System.Func{System.Type,System.Object,System.Boolean},DryIoc.IReuse)">
            <summary>Automatically resolves non-registered service type which is: nor interface, nor abstract.
            The resolution creates Transient services.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithAutoConcreteTypeResolution(System.Func{DryIoc.Request,System.Boolean})">
            Replaced with `WithConcreteTypeDynamicRegistrations`
        </member>
        <member name="M:DryIoc.Rules.AutoFallbackDynamicRegistrations(System.Func{System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Type}},System.Func{System.Type,DryIoc.Factory})">
            <summary>Creates dynamic fallback registrations for the requested service type
            with provided <paramref name="getImplementationTypes"/>.
            Fallback means that the dynamic registrations will be applied Only if no normal registrations
            exist for the requested service type, hence the "fallback".</summary>
            <param name="getImplementationTypes">Implementation types to select for service.</param>
            <param name="factory">(optional) Handler to customize the factory, e.g.
            specify reuse or setup. Handler should not return <c>null</c>.</param>
            <returns>Registration provider.</returns>
        </member>
        <member name="M:DryIoc.Rules.AutoRegisterUnknownServiceRule(System.Collections.Generic.IEnumerable{System.Type},System.Func{DryIoc.IReuse,DryIoc.Request,DryIoc.IReuse},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Obsolete: replaced by <see cref="M:DryIoc.Rules.AutoFallbackDynamicRegistrations(System.Func{System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Type}},System.Func{System.Type,DryIoc.Factory})"/></summary>
        </member>
        <member name="P:DryIoc.Rules.DefaultReuse">
            <summary>See <see cref="M:DryIoc.Rules.WithDefaultReuse(DryIoc.IReuse)"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithDefaultReuse(DryIoc.IReuse)">
            <summary>The reuse used in case if reuse is unspecified (null) in Register methods.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDefaultReuseInsteadOfTransient(DryIoc.IReuse)">
            <summary>Replaced by WithDefaultReuse because for some cases InsteadOfTransient does not make sense.</summary>
        </member>
        <member name="T:DryIoc.Rules.ItemToExpressionConverterRule">
            <summary>Given item object and its type should return item "pure" expression presentation,
            without side-effects or external dependencies.
            e.g. for string "blah" <code lang="cs"><![CDATA[]]>Expression.Constant("blah", typeof(string))</code>.
            If unable to convert should return null.</summary>
        </member>
        <member name="P:DryIoc.Rules.ItemToExpressionConverter">
            <summary><see cref="M:DryIoc.Rules.WithItemToExpressionConverter(DryIoc.Rules.ItemToExpressionConverterRule)"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithItemToExpressionConverter(DryIoc.Rules.ItemToExpressionConverterRule)">
            <summary>Specifies custom rule to convert non-primitive items to their expression representation.
            That may be required because DryIoc by default does not support non-primitive service keys and registration metadata.
            To enable non-primitive values support DryIoc need a way to recreate them as expression tree.</summary>
        </member>
        <member name="P:DryIoc.Rules.ThrowIfDependencyHasShorterReuseLifespan">
            <summary><see cref="M:DryIoc.Rules.WithoutThrowIfDependencyHasShorterReuseLifespan"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutThrowIfDependencyHasShorterReuseLifespan">
            <summary>Turns off throwing exception when dependency has shorter reuse lifespan than its parent or ancestor.</summary>
            <returns>New rules with new setting value.</returns>
        </member>
        <member name="P:DryIoc.Rules.ThrowIfScopedOrSingletonHasTransientDependency">
            <summary><see cref="M:DryIoc.Rules.WithThrowIfScopedOrSingletonHasTransientDependency"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithThrowIfScopedOrSingletonHasTransientDependency">
            <summary>Turns On throwing the exception when Singleton or Scope service has a Transient dependency</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutThrowIfScopedOrSingletonHasTransientDependency">
            <summary>Turns Off throwing the exception when Singleton or Scope service has a Transient dependency (the default)</summary>
        </member>
        <member name="P:DryIoc.Rules.ThrowOnRegisteringDisposableTransient">
            <summary><see cref="M:DryIoc.Rules.WithoutThrowOnRegisteringDisposableTransient"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutThrowOnRegisteringDisposableTransient">
            <summary>Turns Off the rule <see cref="P:DryIoc.Rules.ThrowOnRegisteringDisposableTransient"/>.
            Allows to register disposable transient but it is up to you to handle their disposal.
            You can use <see cref="M:DryIoc.Rules.WithTrackingDisposableTransients"/> to actually track disposable transient in
            container, so that disposal will be handled by container.</summary>
        </member>
        <member name="P:DryIoc.Rules.TrackingDisposableTransients">
            <summary><see cref="M:DryIoc.Rules.WithTrackingDisposableTransients"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithTrackingDisposableTransients">
             <summary>Turns tracking of disposable transients in dependency parent scope, or in current scope if service
             is resolved directly.
            
             If there is no open scope at the moment then resolved transient won't be tracked and it is up to you
             to dispose it! That's is similar situation to creating service by new - you have full control.
            
             If dependency wrapped in Func somewhere in parent chain then it also won't be tracked, because
             Func supposedly means multiple object creation and for container it is not clear what to do, so container
             delegates that to user. Func here is the similar to Owned relationship type in Autofac library.
             </summary>
             <remarks>Turning this setting On automatically turns off <see cref="P:DryIoc.Rules.ThrowOnRegisteringDisposableTransient"/>.</remarks>
        </member>
        <member name="P:DryIoc.Rules.EagerCachingSingletonForFasterAccess">
            <summary><see cref="M:DryIoc.Rules.WithoutEagerCachingSingletonForFasterAccess"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutEagerCachingSingletonForFasterAccess">
            <summary>Turns off optimization: creating singletons during resolution of object graph.</summary>
        </member>
        <member name="P:DryIoc.Rules.DependencyResolutionCallExprs">
            <summary><see cref="M:DryIoc.Rules.WithExpressionGeneration(System.Boolean)"/>.</summary>
        </member>
        <member name="P:DryIoc.Rules.UsedForExpressionGeneration">
            <summary>Indicates that container is used for generation purposes, so it should use less runtime state</summary>
        </member>
        <member name="M:DryIoc.Rules.WithExpressionGeneration(System.Boolean)">
            <summary>Specifies to generate ResolutionCall dependency creation expression and stores the result 
            in the-per rules collection.</summary>
        </member>
        <member name="P:DryIoc.Rules.UsedForValidation">
            <summary>Indicates that rules are used for the validation, e.g. the rules created in `Validate` method</summary>
        </member>
        <member name="M:DryIoc.Rules.ForValidate">
            <summary>Specifies to generate ResolutionCall dependency creation expression and stores the result 
            in the-per rules collection.</summary>
        </member>
        <member name="P:DryIoc.Rules.ImplicitCheckForReuseMatchingScope">
            <summary><see cref="P:DryIoc.Rules.ImplicitCheckForReuseMatchingScope"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutImplicitCheckForReuseMatchingScope">
            <summary>Removes implicit Factory <see cref="P:DryIoc.Setup.Condition"/> for non-transient service.
            The Condition filters out factory without matching scope.</summary>
        </member>
        <member name="M:DryIoc.Rules.ForExpressionGeneration(System.Boolean)">
            <summary>Removes runtime optimizations preventing an expression generation.</summary>
        </member>
        <member name="P:DryIoc.Rules.ResolveIEnumerableAsLazyEnumerable">
            <summary><see cref="M:DryIoc.Rules.WithResolveIEnumerableAsLazyEnumerable"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithResolveIEnumerableAsLazyEnumerable">
            <summary>Specifies to resolve IEnumerable as LazyEnumerable.</summary>
        </member>
        <member name="P:DryIoc.Rules.VariantGenericTypesInResolvedCollection">
            <summary><see cref="M:DryIoc.Rules.WithVariantGenericTypesInResolvedCollection"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithVariantGenericTypesInResolvedCollection">
            <summary>Flag instructs to include covariant compatible types into the resolved collection.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutVariantGenericTypesInResolvedCollection">
            <summary>Flag instructs to exclude covariant compatible types into the resolved collection.</summary>
        </member>
        <member name="P:DryIoc.Rules.VariantGenericTypesInResolve">
            <summary><see cref="M:DryIoc.Rules.WithVariantGenericTypesInResolve"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithVariantGenericTypesInResolve">
            <summary>Flag instructs to include covariant compatible types into the resolved generic.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutVariantGenericTypesInResolve">
            <summary>Flag instructs to exclude covariant compatible types into the resolved generic.</summary>
        </member>
        <member name="P:DryIoc.Rules.DefaultIfAlreadyRegistered">
            <summary><see cref="M:DryIoc.Rules.WithDefaultIfAlreadyRegistered(DryIoc.IfAlreadyRegistered)"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDefaultIfAlreadyRegistered(DryIoc.IfAlreadyRegistered)">
            <summary>Specifies default setting for container. By default is <see cref="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed"/>.
            Example of use: specify Keep as a container default, then set AppendNonKeyed for explicit collection registrations.</summary>
        </member>
        <member name="P:DryIoc.Rules.ThrowIfRuntimeStateRequired">
            <summary><see cref="M:DryIoc.Rules.WithThrowIfRuntimeStateRequired"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithThrowIfRuntimeStateRequired">
            <summary>Specifies to throw an exception in attempt to resolve service which require runtime state for resolution.
            Runtime state may be introduced by RegisterDelegate, RegisterInstance, or registering with non-primitive service key, or metadata.</summary>
        </member>
        <member name="P:DryIoc.Rules.CaptureContainerDisposeStackTrace">
            <summary><see cref="M:DryIoc.Rules.WithCaptureContainerDisposeStackTrace"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithCaptureContainerDisposeStackTrace">
            <summary>Instructs to capture Dispose stack-trace to include it later into <see cref="F:DryIoc.Error.ContainerIsDisposed"/>
            exception for easy diagnostics.</summary>
        </member>
        <member name="P:DryIoc.Rules.IgnoringReuseForFuncWithArgs">
            <summary>Allows Func with args specify its own reuse (sharing) behavior.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithIgnoringReuseForFuncWithArgs">
            <summary>Allows Func with args specify its own reuse (sharing) behavior.</summary>
        </member>
        <member name="P:DryIoc.Rules.FuncAndLazyWithoutRegistration">
            <summary>Allows Func of service to be resolved even without registered service.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithFuncAndLazyWithoutRegistration">
            <summary>Allows Func of service to be resolved even without registered service.</summary>
        </member>
        <member name="P:DryIoc.Rules.UseFastExpressionCompiler">
            Commands to use FastExpressionCompiler - set by default.
        </member>
        <member name="M:DryIoc.Rules.WithoutFastExpressionCompiler">
            Fallbacks to system `Expression.Compile()`
        </member>
        <member name="P:DryIoc.Rules.UseInterpretationForTheFirstResolution">
            Subject-subject
        </member>
        <member name="M:DryIoc.Rules.WithoutInterpretationForTheFirstResolution">
            Fallbacks to system `Expression.Compile()`
        </member>
        <member name="P:DryIoc.Rules.UseInterpretation">
            Subject
        </member>
        <member name="M:DryIoc.Rules.WithUseInterpretation">
            <summary>Uses DryIoc own interpretation mechanism or is falling back to `Compile(preferInterpretation: true)`</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutUseInterpretation">
            <summary>Uses DryIoc own interpretation mechanism or is falling back to `Compile(preferInterpretation: true)`</summary>
        </member>
        <member name="P:DryIoc.Rules.UseDecorateeReuseForDecorators">
            <summary>If Decorator reuse is not set instructs to use `Decorator.SetupWith(useDecarateeReuse: true)`</summary>
        </member>
        <member name="M:DryIoc.Rules.WithUseDecorateeReuseForDecorators">
            <summary>If Decorator reuse is not set instructs to use `Decorator.SetupWith(useDecarateeReuse: true)`</summary>
        </member>
        <member name="M:DryIoc.Rules.ToString">
            Outputs most notable non-default rules
        </member>
        <member name="T:DryIoc.FactoryMethod">
            <summary>Wraps constructor or factory method optionally with factory instance to create service.</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.ConstructorOrMethodOrMember">
            <summary>Constructor or method to use for service creation.</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.FactoryServiceInfo">
            <summary>Identifies factory service if factory method is instance member.</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.FactoryExpression">
            Alternatively you may just provide an expression for factory
        </member>
        <member name="F:DryIoc.FactoryMethod.ResolvedParameterExpressions">
            <summary> Contains resolved parameter expressions found when looking for most resolvable constructor</summary> 
        </member>
        <member name="M:DryIoc.FactoryMethod.Of(System.Reflection.MemberInfo,DryIoc.ServiceInfo)">
            <summary>Wraps method and factory instance.
            Where <paramref name="ctorOrMethodOrMember"/> is constructor, static or instance method, property or field.</summary>
        </member>
        <member name="M:DryIoc.FactoryMethod.Of(System.Reflection.MemberInfo,System.Object)">
            <summary>Wraps method and factory instance.
            Where <paramref name="methodOrMember"/> is constructor, static or instance method, property or field.</summary>
        </member>
        <member name="M:DryIoc.FactoryMethod.Of``1(System.String)">
            <summary>Discovers the static factory method or member by name in <typeparamref name="TFactory"/>.
            Should play nice with C# <see langword="nameof"/> operator.</summary>
        </member>
        <member name="M:DryIoc.FactoryMethod.ToString">
            <summary>Pretty prints wrapped method.</summary>
        </member>
        <member name="M:DryIoc.FactoryMethod.Constructor(System.Boolean,System.Boolean)">
            <summary>Easy way to specify non-public and most resolvable constructor.</summary>
            <param name="mostResolvable">(optional) Instructs to select constructor with max number of params which all are resolvable.</param>
            <param name="includeNonPublic">(optional) Consider the non-public constructors.</param>
            <returns>Constructor or null if not found.</returns>
        </member>
        <member name="M:DryIoc.FactoryMethod.DefaultConstructor(System.Boolean)">
            <summary>Easy way to specify default constructor to be used for resolution.</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.ConstructorWithResolvableArguments">
            Better be named `ConstructorWithMostResolvableArguments`.
            Searches for public constructor with most resolvable parameters or throws <see cref="T:DryIoc.ContainerException"/> if not found.
            Works both for resolving service and `Func{TArgs..., TService}`
        </member>
        <member name="F:DryIoc.FactoryMethod.ConstructorWithResolvableArgumentsIncludingNonPublic">
            <summary>Searches for constructor (including non public ones) with most
            resolvable parameters or throws <see cref="T:DryIoc.ContainerException"/> if not found.
            Works both for resolving service and Func{TArgs..., TService}</summary>
        </member>
        <member name="M:DryIoc.FactoryMethod.#ctor(System.Reflection.ConstructorInfo)">
            <summary>Just creates a thingy from the constructor</summary>
        </member>
        <member name="T:DryIoc.Made">
            <summary>Rules how to: <list type="bullet">
            <item>Select constructor for creating service with <see cref="P:DryIoc.Made.FactoryMethod"/>.</item>
            <item>Specify how to resolve constructor parameters with <see cref="P:DryIoc.Made.Parameters"/>.</item>
            <item>Specify what properties/fields to resolve and how with <see cref="P:DryIoc.Made.PropertiesAndFields"/>.</item>
            </list></summary>
        </member>
        <member name="P:DryIoc.Made.FactoryMethod">
            <summary>Returns delegate to select constructor based on provided request.</summary>
        </member>
        <member name="P:DryIoc.Made.FactoryMethodKnownResultType">
            <summary>Return type of strongly-typed factory method expression.</summary>
        </member>
        <member name="P:DryIoc.Made.IsConditional">
            Has any conditional flags
        </member>
        <member name="P:DryIoc.Made.HasCustomDependencyValue">
            True is made has properties or parameters with custom value.
            That's mean the whole made become context based which affects caching.
        </member>
        <member name="P:DryIoc.Made.IsConditionalImplementation">
            <summary>Indicates that the implementation type depends on request.</summary>
        </member>
        <member name="P:DryIoc.Made.IsImplMemberDependsOnRequest">
            Indicates that the member depends on request
        </member>
        <member name="P:DryIoc.Made.Parameters">
            <summary>Specifies how constructor parameters should be resolved:
            parameter service key and type, throw or return default value if parameter is unresolved.</summary>
        </member>
        <member name="P:DryIoc.Made.PropertiesAndFields">
            <summary>Specifies what <see cref="T:DryIoc.ServiceInfo"/> should be used when resolving property or field.</summary>
        </member>
        <member name="M:DryIoc.Made.ToString">
            <summary>Outputs whatever is possible (known) for Made</summary>
        </member>
        <member name="F:DryIoc.Made.Default">
            <summary>Container will use some sensible defaults for service creation.</summary>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.FactoryMethodSelector)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.FactoryMethod"/> specified.</summary>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.ParameterSelector)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.Parameters"/> specified.</summary>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.PropertiesAndFieldsSelector)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.PropertiesAndFields"/> specified.</summary>
        </member>
        <member name="M:DryIoc.Made.Of(DryIoc.FactoryMethodSelector,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector,System.Boolean)">
            <summary>Specifies injections rules for Constructor, Parameters, Properties and Fields. If no rules specified returns <see cref="F:DryIoc.Made.Default"/> rules.</summary>
        </member>
        <member name="M:DryIoc.Made.Of(DryIoc.FactoryMethod,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Specifies injections rules for Constructor, Parameters, Properties and Fields. If no rules specified returns <see cref="F:DryIoc.Made.Default"/> rules.</summary>
            <param name="factoryMethod">Known factory method.</param>
            <param name="parameters">(optional)</param> <param name="propertiesAndFields">(optional)</param>
            <returns>New injection rules.</returns>
        </member>
        <member name="M:DryIoc.Made.Of(System.Reflection.MemberInfo,DryIoc.ServiceInfo,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates factory method specification</summary>
        </member>
        <member name="M:DryIoc.Made.Of(System.Func{DryIoc.Request,System.Type},DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates factory specification with implementation type, conditionally depending on request.</summary>
        </member>
        <member name="M:DryIoc.Made.Of(System.Func{DryIoc.Request,System.Reflection.MemberInfo},DryIoc.ServiceInfo,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates factory specification with method or member selector based on request.
            Where <paramref name="getMethodOrMember"/> is method, or constructor, or member selector.</summary>
        </member>
        <member name="M:DryIoc.Made.Of(System.Func{DryIoc.Request,System.Reflection.MemberInfo},System.Func{DryIoc.Request,DryIoc.ServiceInfo},DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates factory specification with method or member selector based on request.
            Where <paramref name="getMethodOrMember"/>Method, or constructor, or member selector.</summary>
        </member>
        <member name="M:DryIoc.Made.Of(System.Func{System.Type,System.Reflection.ConstructorInfo},DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Defines how to select constructor from implementation type.
            Where <paramref name="getConstructor"/> is delegate taking implementation type as input 
            and returning selected constructor info.</summary>
        </member>
        <member name="M:DryIoc.Made.Of``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Func{DryIoc.Request,System.Object}[])">
            <summary>Defines factory method using expression of constructor call (with properties), or static method call.</summary>
            <typeparam name="TService">Type with constructor or static method.</typeparam>
            <param name="serviceReturningExpr">Expression tree with call to constructor with properties:
            <code lang="cs"><![CDATA[() => new Car(Arg.Of<IEngine>()) { Color = Arg.Of<Color>("CarColor") }]]></code>
            or static method call <code lang="cs"><![CDATA[() => Car.Create(Arg.Of<IEngine>())]]></code></param>
            <param name="argValues">(optional) Primitive custom values for dependencies.</param>
            <returns>New Made specification.</returns>
        </member>
        <member name="M:DryIoc.Made.Of``2(System.Func{DryIoc.Request,DryIoc.ServiceInfo.Typed{``0}},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{DryIoc.Request,System.Object}[])">
            <summary>Defines creation info from factory method call Expression without using strings.
            You can supply any/default arguments to factory method, they won't be used, it is only to find the <see cref="T:System.Reflection.MethodInfo"/>.</summary>
            <typeparam name="TFactory">Factory type.</typeparam> <typeparam name="TService">Factory product type.</typeparam>
            <param name="getFactoryInfo">Returns or resolves factory instance.</param>
            <param name="serviceReturningExpr">Method, property or field expression returning service.</param>
            <param name="argValues">(optional) Primitive custom values for dependencies.</param>
            <returns>New Made specification.</returns>
        </member>
        <member name="M:DryIoc.Made.Of``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{DryIoc.Request,System.Object}[])">
            Composes Made.Of expression with known factory instance and expression to get a service
        </member>
        <member name="T:DryIoc.Made.TypedMade`1">
            <summary>Typed version of <see cref="T:DryIoc.Made"/> specified with statically typed expression tree.</summary>
        </member>
        <member name="T:DryIoc.Arg">
            <summary>Class for defining parameters/properties/fields service info in <see cref="T:DryIoc.Made"/> expressions.
            Arg methods are NOT actually called, they just used to reflect service info from call expression.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1">
            <summary>Specifies required service type of parameter or member. If required type is the same as parameter/member type,
            the method is just a placeholder to help detect constructor or factory method, and does not have additional meaning.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``2">
            <summary>Specifies both service and required service types.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1(DryIoc.IfUnresolved)">
            <summary>Specifies required service type of parameter or member. Plus specifies if-unresolved policy.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``2(DryIoc.IfUnresolved)">
            <summary>Specifies both service and required service types.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1(System.Object)">
            <summary>Specifies required service type of parameter or member. Plus specifies service key.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``2(System.Object)">
            <summary>Specifies both service and required service types.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1(System.String,System.Object)">
            <summary>Specifies required service type of parameter or member. Plus specifies service key.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``2(System.String,System.Object)">
            <summary>Specifies both service and required service types.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1(DryIoc.IfUnresolved,System.Object)">
            <summary>Specifies required service type of parameter or member. Plus specifies if-unresolved policy. Plus specifies service key.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``2(DryIoc.IfUnresolved,System.Object)">
            <summary>Specifies both service and required service types.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1(``0,DryIoc.IfUnresolved)">
            <summary>Specifies required service type, default value and <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1(``0,DryIoc.IfUnresolved,System.Object)">
            <summary>Specifies required service type, default value and <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</summary>
        </member>
        <member name="M:DryIoc.Arg.Index``1(System.Int32)">
            <summary>Specifies argument index starting from 0 to use corresponding custom value factory,
            similar to String.Format <c>"{0}, {1}, etc"</c>.</summary>
        </member>
        <member name="F:DryIoc.Arg.ArgIndexMethodName">
            <summary>Name is close to method itself to not forget when renaming the method.</summary>
        </member>
        <member name="T:DryIoc.Registrator">
            <summary>Contains <see cref="T:DryIoc.IRegistrator"/> extension methods to simplify general use cases.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,DryIoc.Factory,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>The base method for registering service with its implementation factory. Allows to specify all possible options.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers service <paramref name="serviceType"/> with corresponding <paramref name="implementationType"/>.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers service of <paramref name="serviceAndMayBeImplementationType"/>.
            ServiceType may be the same as <paramref name="serviceAndMayBeImplementationType"/>.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register``2(DryIoc.IRegistrator,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers service of <typeparamref name="TService"/> type
            implemented by <typeparamref name="TImplementation"/> type.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register``1(DryIoc.IRegistrator,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers implementation type <typeparamref name="TImplementation"/> with itself as service type.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register``2(DryIoc.IRegistrator,DryIoc.Made.TypedMade{``1},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers service type returned by Made expression.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register``1(DryIoc.IRegistrator,DryIoc.Made.TypedMade{``0},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers service returned by Made expression.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstance(DryIoc.IRegistrator,System.Boolean,System.Type,System.Object,System.Nullable{DryIoc.IfAlreadyRegistered},DryIoc.Setup,System.Object)">
            <summary>
            Registers the instance creating a "normal" DryIoc registration so you can check it via `IsRegestered`, 
            apply wrappers and decorators, etc.
            Additionally, if instance is `IDisposable`, then it tracks it in a singleton scope.
            NOTE: Look at the `Use` method to put instance directly into current or singleton scope,
            though without ability to use decorators and wrappers on it.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstance(DryIoc.IRegistrator,System.Type,System.Object,System.Nullable{DryIoc.IfAlreadyRegistered},DryIoc.Setup,System.Object)">
            <summary>
            Registers the instance creating a "normal" DryIoc registration so you can check it via `IsRegestered`, 
            apply wrappers and decorators, etc.
            Additionally, if instance is `IDisposable`, then it tracks it in a singleton scope.
            NOTE: Look at the `Use` method to put instance directly into current or singleton scope,
            though without ability to use decorators and wrappers on it.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstance``1(DryIoc.IRegistrator,``0,System.Nullable{DryIoc.IfAlreadyRegistered},DryIoc.Setup,System.Object)">
            <summary>
            Registers the instance creating a "normal" DryIoc registration so you can check it via `IsRegestered`, 
            apply wrappers and decorators, etc.
            Additionally, if instance is `IDisposable`, then it tracks it in a singleton scope.
            NOTE: Look at the `Use` method to put instance directly into current or singleton scope,
            though without ability to use decorators and wrappers on it.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstanceMany(DryIoc.IRegistrator,System.Type,System.Object,System.Boolean,System.Nullable{DryIoc.IfAlreadyRegistered},DryIoc.Setup,System.Object)">
            <summary>
            Registers the instance with possible multiple service types creating a "normal" DryIoc registration 
            so you can check it via `IsRegestered` for each service type, 
            apply wrappers and decorators, etc.
            Additionally, if instance is `IDisposable`, then it tracks it in a singleton scope.
            NOTE: Look at the `Use` method to put instance directly into current or singleton scope,
            though without ability to use decorators and wrappers on it.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstanceMany``1(DryIoc.IRegistrator,``0,System.Boolean,System.Nullable{DryIoc.IfAlreadyRegistered},DryIoc.Setup,System.Object)">
            <summary>
            Registers the instance with possible multiple service types creating a "normal" DryIoc registration 
            so you can check it via `IsRegestered` for each service type, 
            apply wrappers and decorators, etc.
            Additionally, if instance is `IDisposable`, then it tracks it in a singleton scope.
            NOTE: Look at the `Use` method to put instance directly into current or singleton scope,
            though without ability to use decorators and wrappers on it.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstanceMany(DryIoc.IRegistrator,System.Type[],System.Object,System.Nullable{DryIoc.IfAlreadyRegistered},DryIoc.Setup,System.Object)">
            <summary>
            Registers the instance with possible multiple service types creating a "normal" DryIoc registration 
            so you can check it via `IsRegestered` for each service type, 
            apply wrappers and decorators, etc.
            Additionally, if instance is `IDisposable`, then it tracks it in a singleton scope.
            NOTE: Look at the `Use` method to put instance directly into current or singleton scope,
            though without ability to use decorators and wrappers on it.
            </summary>
        </member>
        <member name="F:DryIoc.Registrator.ExcludedGeneralPurposeServiceTypes">
            <summary>List of types excluded by default from RegisterMany convention.</summary>
        </member>
        <member name="M:DryIoc.Registrator.IsExcludedGeneralPurposeServiceType(System.Type)">
            <summary>Checks that type is not in the list of <see cref="F:DryIoc.Registrator.ExcludedGeneralPurposeServiceTypes"/>.</summary>
        </member>
        <member name="M:DryIoc.Registrator.IsServiceType(System.Type)">
            <summary>Checks that type can be used a service type.</summary>
        </member>
        <member name="M:DryIoc.Registrator.IsImplementationType(System.Type)">
            <summary>Checks if type can be used as implementation type for reflection factory,
            and therefore registered to container. Usually used to discover implementation types from assembly.</summary>
        </member>
        <member name="M:DryIoc.Registrator.GetImplementedServiceTypes(System.Type,System.Boolean)">
            <summary>Returns only those types that could be used as service types of <paramref name="type"/>.
            It means that for open-generic <paramref name="type"/> its service type should supply all type arguments.</summary>
        </member>
        <member name="M:DryIoc.Registrator.IsImplementingServiceType(System.Type,System.Type)">
            <summary>The same `GetImplementedServiceTypes` but instead of collecting the service types just check the <paramref name="serviceType"/> is implemented</summary>
        </member>
        <member name="M:DryIoc.Registrator.GetRegisterManyImplementedServiceTypes(System.Type,System.Boolean)">
            <summary>Returns the sensible services automatically discovered for RegisterMany implementation type.
            Excludes the collection wrapper interfaces. The <paramref name="type"/> may be concrete, abstract or
            generic definition.</summary>
        </member>
        <member name="M:DryIoc.Registrator.GetImplementationTypes(System.Reflection.Assembly)">
            <summary>Returns the types suitable to be an implementation types for <see cref="T:DryIoc.ReflectionFactory"/>:
            actually a non abstract and not compiler generated classes.</summary>
        </member>
        <member name="M:DryIoc.Registrator.GetImplementationTypes(System.Reflection.Assembly,System.Func{System.Type,System.Boolean})">
            <summary>Returns the types suitable to be an implementation types for <see cref="T:DryIoc.ReflectionFactory"/>:
            actually a non abstract and not compiler generated classes.</summary>
        </member>
        <member name="F:DryIoc.Registrator.Interfaces">
            <summary>Sugar, so you can say <code lang="cs"><![CDATA[r.RegisterMany<X>(Registrator.Interfaces)]]></code></summary>
        </member>
        <member name="M:DryIoc.Registrator.ImplementsServiceType(System.Type,System.Type)">
            <summary>Checks if <paramref name="type"/> implements a service type,
            along the checking if <paramref name="type"/> is a valid implementation type.</summary>
        </member>
        <member name="M:DryIoc.Registrator.ImplementsServiceType``1(System.Type)">
            <summary>Checks if <paramref name="type"/> implements a service type,
            along the checking if <paramref name="type"/> and service type
            are valid implementation and service types.</summary>
        </member>
        <member name="M:DryIoc.Registrator.ToFactory(System.Type)">
            <summary>Wraps the implementation type in factory.</summary>
        </member>
        <member name="M:DryIoc.Registrator.ToFactory(System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup)">
            <summary>Wraps the implementation type in factory plus allow to provide factory parameters.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Type},System.Func{System.Type,System.Type[]},System.Func{System.Type,DryIoc.Factory},System.Func{System.Type,System.Type,System.Object},System.Nullable{DryIoc.IfAlreadyRegistered})">
            <summary>
            Batch registering the implementations with possibly many service types,
            throwing the <see cref="F:DryIoc.Error.NoServicesWereRegisteredByRegisterMany" /> error when there are no services types to register.
            You may pass the predefined <see cref="M:DryIoc.Registrator.GetRegisterManyImplementedServiceTypes(System.Type,System.Boolean)"/> to <paramref name="getServiceTypes"/>.
            By default <paramref name="getImplFactory"/> uses the <see cref="T:DryIoc.ReflectionFactory"/> with the default reuse,
            or you may return the <see cref="T:DryIoc.ReflectionFactory"/> with the <see cref="T:DryIoc.Reuse"/> of your choice.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterManyIgnoreNoServicesWereRegistered(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Type},System.Func{System.Type,System.Type[]},System.Func{System.Type,DryIoc.Factory},System.Func{System.Type,System.Type,System.Object},System.Nullable{DryIoc.IfAlreadyRegistered})">
            <summary>
            Batch registering the implementations with possibly many service types,
            ignoring the case when there are no services types to register.
            You may pass the predefined <see cref="M:DryIoc.Registrator.GetRegisterManyImplementedServiceTypes(System.Type,System.Boolean)"/> to <paramref name="getServiceTypes"/>.
            By default <paramref name="getImplFactory"/> uses the <see cref="T:DryIoc.ReflectionFactory"/> with the default reuse,
            or you may return the <see cref="T:DryIoc.ReflectionFactory"/> with the <see cref="T:DryIoc.Reuse"/> of your choice.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Type[],System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Batch registers implementation with possibly many service types.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Func{System.Type,System.Type[]},System.Func{System.Type,DryIoc.Factory},System.Func{System.Type,System.Type,System.Object},System.Nullable{DryIoc.IfAlreadyRegistered})">
            <summary>Batch registers assemblies of implementation types with possibly many service types.
            The default factory is the <see cref="T:DryIoc.ReflectionFactory"/> with default reuse.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Func{System.Type,System.Boolean},DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Boolean,System.Object)">
            <summary>Registers many implementations with their auto-figured service types.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Type},DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Func{System.Type,System.Boolean},System.Boolean,System.Object)">
            <summary>Registers many implementations with auto-figured service types.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany``1(DryIoc.IRegistrator,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Func{System.Type,System.Boolean},System.Boolean,System.Object)">
            <summary>Registers single registration for all implemented public interfaces and base classes.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany``1(DryIoc.IRegistrator,DryIoc.Made.TypedMade{``0},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Func{System.Type,System.Boolean},System.Boolean,System.Object)">
            <summary>Registers single registration for all implemented public interfaces and base classes.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``1(DryIoc.IRegistrator,System.Func{DryIoc.IResolverContext,``0},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers a factory delegate for creating an instance of <typeparamref name="TService"/>.
            Delegate can use resolver context parameter to resolve any required dependencies, e.g.:
            <code lang="cs"><![CDATA[container.RegisterDelegate<ICar>(r => new Car(r.Resolve<IEngine>()))]]></code></summary>
            <remarks>The alternative to this method please consider using <see cref="T:DryIoc.Made"/> instead:
            <code lang="cs"><![CDATA[container.Register<ICar>(Made.Of(() => new Car(Arg.Of<IEngine>())))]]></code>.
            </remarks>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``1(DryIoc.IRegistrator,System.Func{``0},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate to be injected by container avoiding the ServiceLocator anti-pattern</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``2(DryIoc.IRegistrator,System.Func{``0,``1},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``1(DryIoc.IRegistrator,System.Type,System.Func{``0,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``3(DryIoc.IRegistrator,System.Func{``0,``1,``2},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``4(DryIoc.IRegistrator,System.Func{``0,``1,``2,``3},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``5(DryIoc.IRegistrator,System.Func{``0,``1,``2,``3,``4},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``6(DryIoc.IRegistrator,System.Func{``0,``1,``2,``3,``4,``5},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``7(DryIoc.IRegistrator,System.Func{``0,``1,``2,``3,``4,``5,``6},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``8(DryIoc.IRegistrator,System.Func{``0,``1,``2,``3,``4,``5,``6,``7},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
        </member>
        <member name="M:DryIoc.Registrator.ToFactoryDelegate``1(System.Func{DryIoc.IResolverContext,``0},DryIoc.IResolverContext)">
            Minimizes the number of allocations when converting from Func to named delegate
        </member>
        <member name="M:DryIoc.Registrator.ToFactoryDelegate(System.Object,DryIoc.IResolverContext)">
            Lifts the result to the factory delegate without allocations on capturing value in lambda closure
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate(DryIoc.IRegistrator,System.Type,System.Func{DryIoc.IResolverContext,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers a factory delegate for creating an instance of <paramref name="serviceType"/>.
            Delegate can use resolver context parameter to resolve any required dependencies, e.g.:
            <code lang="cs"><![CDATA[container.RegisterDelegate<ICar>(r => new Car(r.Resolve<IEngine>()))]]></code></summary>
            <remarks>IMPORTANT: The method should be used as the last resort only! Though powerful it is a black-box for container,
            which prevents diagnostics, plus it is easy to get memory leaks (due variables captured in delegate closure),
            and impossible to use in compile-time scenarios.
            Consider using <see cref="T:DryIoc.Made"/> instead:
            <code lang="cs"><![CDATA[container.Register<ICar>(Made.Of(() => new Car(Arg.Of<IEngine>())))]]></code>
            </remarks>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate(DryIoc.IRegistrator,System.Boolean,System.Type,System.Func{DryIoc.IResolverContext,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            A special performant version mostly for integration with other libraries,
            that already check compatibility between delegate result and the service type
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegateDecorator``1(DryIoc.IRegistrator,System.Func{DryIoc.IResolverContext,System.Func{``0,``0}},System.Func{DryIoc.Request,System.Boolean})">
            <summary>[Obsolete("Replaced with RegisterDelegate{Dep1...Dep2, R}()")]</summary>
        </member>
        <member name="M:DryIoc.Registrator.UseInstance``1(DryIoc.IResolverContext,``0,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.UseInstance``1(DryIoc.IRegistrator,``0,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.UseInstance``1(DryIoc.IContainer,``0,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.UseInstance(DryIoc.IResolverContext,System.Type,System.Object,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.UseInstance(DryIoc.IRegistrator,System.Type,System.Object,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.UseInstance(DryIoc.IContainer,System.Type,System.Object,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.UseInstance``1(DryIoc.IResolverContext,``0,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.UseInstance(DryIoc.IResolverContext,System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.UseInstance(DryIoc.IRegistrator,System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.UseInstance(DryIoc.IContainer,System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            <summary>
            Will become OBSOLETE in the next major version!
            Please use `RegisterInstance` or `Use` method instead.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IResolverContext,System.Func{DryIoc.IResolverContext,``0})">
            <summary>Adding the factory directly to scope for resolution</summary> 
        </member>
        <member name="M:DryIoc.Registrator.Use(DryIoc.IResolverContext,System.Type,System.Object)">
            <summary>Adding the instance directly to the scope for resolution</summary>
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IResolverContext,``0)">
            <summary>Adding the instance directly to the scope for resolution</summary> 
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IRegistrator,System.Func{DryIoc.IResolverContext,``0})">
            <summary>Adding the factory directly to the scope for resolution</summary>
        </member>
        <member name="M:DryIoc.Registrator.Use(DryIoc.IRegistrator,System.Type,System.Object)">
            <summary>Adding the instance directly to scope for resolution</summary>
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IRegistrator,``0)">
            <summary>Adding the instance directly to scope for resolution</summary> 
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IContainer,System.Func{DryIoc.IResolverContext,``0})">
            <summary>Adding the factory directly to scope for resolution</summary> 
        </member>
        <member name="M:DryIoc.Registrator.Use(DryIoc.IContainer,System.Type,System.Object)">
            <summary>Adding the instance directly to scope for resolution</summary>
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IContainer,``0)">
            <summary>Adding the instance directly to scope for resolution</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInitializer``1(DryIoc.IRegistrator,System.Action{``0,DryIoc.IResolverContext},System.Func{DryIoc.Request,System.Boolean})">
            <summary>
            Registers initializing action that will be called after service is resolved 
            just before returning it to the caller. You can register multiple initializers for a single service.
            Or you can register initializer for the <see cref="T:System.Object"/> type to be applied 
            for all services and use <paramref name="condition"/> to specify the target services.
            Note: The initializer action has the same reuse as a initialized (decorated) service.
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInitializer``1(DryIoc.IRegistrator,System.Action{``0,DryIoc.IResolverContext},DryIoc.IReuse,System.Func{DryIoc.Request,System.Boolean})">
            <summary>
            Registers initializing action that will be called after service is resolved 
            just before returning it to the caller. You can register multiple initializers for a single service.
            Or you can register initializer for the <see cref="T:System.Object"/> type to be applied 
            for all services and use <paramref name="condition"/> to specify the target services.
            Note: You may specify a <paramref name="reuse"/> different from the initiliazed object enabling the
            <paramref name="initialize"/> action to run once (Singleton), run once-per-scope (Scoped), run always (Transient).
            </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDisposer``1(DryIoc.IRegistrator,System.Action{``0},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Registers dispose action for reused target service.</summary>
        </member>
        <member name="M:DryIoc.Registrator.IsRegistered(DryIoc.IRegistrator,System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if <paramref name="serviceType"/> is registered in container OR
            its open generic definition is registered in container.
            The additional implementation factory <paramref name="condition"/> may be specified to narrow the search.</summary>
        </member>
        <member name="M:DryIoc.Registrator.IsRegistered``1(DryIoc.IRegistrator,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if <typeparamref name="TService"/> is registered in container OR
            its open generic definition is registered in container.
            The additional implementation factory <paramref name="condition"/> may be specified to narrow the search.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Unregister(DryIoc.IRegistrator,System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes specified registration from container.
            It also tries to remove the cached resolutions for the removed registration, But it may not work depending on context.
            Check the docs for more info: https://github.com/dadhi/DryIoc/blob/master/docs/DryIoc.Docs/UnregisterAndResolutionCache.md </summary>
        </member>
        <member name="M:DryIoc.Registrator.Unregister``1(DryIoc.IRegistrator,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes specified registration from container.
            It also tries to remove the cached resolutions for the removed registration, But it may not work depending on context.
            Check the docs for more info: https://github.com/dadhi/DryIoc/blob/master/docs/DryIoc.Docs/UnregisterAndResolutionCache.md </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMapping(DryIoc.IRegistrator,System.Type,System.Type,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object,System.Object,DryIoc.FactoryType)">
            <summary>Registers new service type with factory for registered service type.
            Throw if no such registered service type in container.</summary>
            <param name="registrator">Registrator</param> <param name="serviceType">New service type.</param>
            <param name="registeredServiceType">Existing registered service type.</param>
            <param name="ifAlreadyRegistered">The registration to overwrite or preserve the already registered service</param>
            <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
            <param name="factoryType">(optional) By default is <see cref="F:DryIoc.FactoryType.Service"/></param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMapping(DryIoc.IRegistrator,System.Type,System.Type,System.Object,System.Object,DryIoc.FactoryType)">
            <summary>Registers new service type with factory for registered service type.
            Throw if no such registered service type in container.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMapping``2(DryIoc.IRegistrator,System.Object,System.Object,DryIoc.FactoryType)">
            <summary>Registers new service type with factory for registered service type.
            Throw if no such registered service type in container.</summary>
            <param name="registrator">Registrator</param>
            <typeparam name="TService">New service type.</typeparam>
            <typeparam name="TRegisteredService">Existing registered service type.</typeparam>
            <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
            <param name="factoryType">(optional) By default is <see cref="F:DryIoc.FactoryType.Service"/></param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMapping``2(DryIoc.IContainer,DryIoc.IfAlreadyRegistered,System.Object,System.Object)">
            <summary>Registers new service type with factory for registered service type.
            Throw if no such registered service type in container.</summary>
            <param name="container">Container</param>
            <typeparam name="TService">New service type.</typeparam>
            <typeparam name="TRegisteredService">Existing registered service type.</typeparam>
            <param name="ifAlreadyRegistered">The registration to overwrite or preserve the already registered service</param>
            <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterPlaceholder(DryIoc.IRegistrator,System.Type,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Register a service without implementation which can be provided later in terms
            of normal registration with IfAlreadyRegistered.Replace parameter.
            When the implementation is still not provided when the placeholder service is accessed,
            then the exception will be thrown.
            This feature allows you to postpone decision on implementation until it is later known.</summary>
            <remarks>Internally the empty factory is registered with the setup asResolutionCall set to true.
            That means, instead of placing service instance into graph expression we put here redirecting call to
            container Resolve.</remarks>
        </member>
        <member name="T:DryIoc.Resolver">
            <summary>Extension methods for <see cref="T:DryIoc.IResolver"/>.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type)">
            <summary>Resolves instance of service type from container. Throws exception if unable to resolve.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,DryIoc.IfUnresolved)">
            <summary>Resolves instance of service type from container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,DryIoc.IfUnresolved)">
            <summary>Resolves instance of type TService from container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,System.Boolean)">
            <summary>Tries to resolve instance of service type from container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,System.Boolean)">
            <summary>Tries to resolve instance of TService from container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,System.Type,DryIoc.IfUnresolved,System.Object[],System.Object)">
            <summary>Returns instance of <paramref name="serviceType"/> searching for <paramref name="requiredServiceType"/>.
            In case of <paramref name="serviceType"/> being generic wrapper like Func, Lazy, IEnumerable, etc. 
            <paramref name="requiredServiceType"/> allow you to specify wrapped service type.</summary>
            <example><code lang="cs"><![CDATA[
                container.Register<IService, Service>();
                var services = container.Resolve(typeof(IEnumerable<object>), typeof(IService));
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,System.Type,DryIoc.IfUnresolved,System.Object[],System.Object)">
            <summary>Returns instance of <typeparamref name="TService"/> searching for <paramref name="requiredServiceType"/>.
            In case of <typeparamref name="TService"/> being generic wrapper like Func, Lazy, IEnumerable, etc. 
            <paramref name="requiredServiceType"/> allow you to specify wrapped service type.</summary>
            <example><code lang="cs"><![CDATA[
                container.Register<IService, Service>();
                var services = container.Resolve<IEnumerable<object>>(typeof(IService));
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``2(DryIoc.IResolver,DryIoc.IfUnresolved,System.Object[],System.Object)">
            <summary>Returns instance of <typeparamref name="TService"/> searching for <typeparamref name="TRequiredService"/>.
            In case of <typeparamref name="TService"/> being generic wrapper like Func, Lazy, IEnumerable, etc. 
            <typeparamref name="TRequiredService"/> allow you to specify wrapped service type.</summary>
            <example><code lang="cs"><![CDATA[
                container.Register<IService, Service>();
                var services = container.Resolve<IEnumerable<object>, IService>();
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,System.Object,DryIoc.IfUnresolved,System.Type,System.Object[])">
            <summary>Returns instance of <paramref name="serviceType"/> searching for <paramref name="requiredServiceType"/>.
            In case of <paramref name="serviceType"/> being generic wrapper like Func, Lazy, IEnumerable, etc., <paramref name="requiredServiceType"/>
            could specify wrapped service type.</summary>
            <remarks>Using <paramref name="requiredServiceType"/> implicitly support Covariance for generic wrappers even in .Net 3.5.</remarks>
            <example><code lang="cs"><![CDATA[
                container.Register<IService, Service>();
                var services = container.Resolve(typeof(Lazy<object>), "someKey", requiredServiceType: typeof(IService));
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,System.Object,DryIoc.IfUnresolved,System.Type,System.Object[])">
            <summary>Returns instance of <typeparamref name="TService"/> type.</summary>
            <typeparam name="TService">The type of the requested service.</typeparam>
            <returns>The requested service instance.</returns>
            <remarks>Using <paramref name="requiredServiceType"/> implicitly support Covariance for generic wrappers even in .Net 3.5.</remarks>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,System.Object[],DryIoc.IfUnresolved,System.Type,System.Object)">
            <summary>Resolves the service supplying all or some of its dependencies 
            (including nested) with the <paramref name="args"/>. The rest of dependencies is injected from
            container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,System.Object[],DryIoc.IfUnresolved,System.Type,System.Object)">
            <summary>Resolves the service supplying all or some of its dependencies 
            (including nested) with the <paramref name="args"/>. The rest of dependencies is injected from
            container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.ResolveMany``1(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object[],System.Object)">
            <summary>Returns all registered services instances including all keyed and default registrations.
            Use <paramref name="behavior"/> to return either all registered services at the moment of resolve (dynamic fresh view) or
            the same services that were returned with first <see cref="M:DryIoc.Resolver.ResolveMany``1(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object[],System.Object)"/> call (fixed view).</summary>
            <typeparam name="TService">Return collection item type. 
            It denotes registered service type if <paramref name="requiredServiceType"/> is not specified.</typeparam>
            <remarks>The same result could be achieved by directly calling:
            <code lang="cs"><![CDATA[
                container.Resolve<LazyEnumerable<IService>>();  // for dynamic result - default behavior
                container.Resolve<IService[]>();                // for fixed array
                container.Resolve<IEnumerable<IService>>();     // same as fixed array
            ]]></code>
            </remarks>
        </member>
        <member name="M:DryIoc.Resolver.ResolveMany(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object[],System.Object)">
            <summary>Returns all registered services as objects, including all keyed and default registrations.</summary>
        </member>
        <member name="M:DryIoc.Resolver.New(DryIoc.IResolver,System.Type,DryIoc.Made,DryIoc.RegistrySharing)">
            <summary>Creates a service by injecting its parameters registered in the container but without registering the service itself in the container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.New``1(DryIoc.IResolver,DryIoc.Made,DryIoc.RegistrySharing)">
            <summary>Creates a service by injecting its parameters registered in the container but without registering the service itself in the container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.New``1(DryIoc.IResolver,DryIoc.Made.TypedMade{``0},DryIoc.RegistrySharing)">
            <summary>Creates a service by injecting its parameters registered in the container but without registering the service itself in the container.</summary>
        </member>
        <member name="T:DryIoc.ResolveManyBehavior">
            <summary>Specifies result of <see cref="M:DryIoc.Resolver.ResolveMany``1(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object[],System.Object)"/>: either dynamic(lazy) or fixed view.</summary>
        </member>
        <member name="F:DryIoc.ResolveManyBehavior.AsLazyEnumerable">
            <summary>Lazy/dynamic item resolve.</summary>
        </member>
        <member name="F:DryIoc.ResolveManyBehavior.AsFixedArray">
            <summary>Fixed array of item at time of resolve, newly registered/removed services won't be listed.</summary>
        </member>
        <member name="T:DryIoc.IsRegistryChangePermitted">
            <summary>Controls the registry change</summary>
        </member>
        <member name="F:DryIoc.IsRegistryChangePermitted.Permitted">
            <summary>Change is permitted - the default setting</summary>
        </member>
        <member name="F:DryIoc.IsRegistryChangePermitted.Error">
            <summary>Throws the error for the new registration</summary>
        </member>
        <member name="F:DryIoc.IsRegistryChangePermitted.Ignored">
            <summary>Ignores the next registration</summary>
        </member>
        <member name="T:DryIoc.IServiceInfo">
            <summary>Provides information required for service resolution: service type
            and optional <see cref="T:DryIoc.ServiceDetails"/></summary>
        </member>
        <member name="P:DryIoc.IServiceInfo.ServiceType">
            <summary>The required piece of info: service type.</summary>
        </member>
        <member name="P:DryIoc.IServiceInfo.Details">
            <summary>Additional optional details: service key, if-unresolved policy, required service type.</summary>
        </member>
        <member name="M:DryIoc.IServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
        </member>
        <member name="T:DryIoc.ServiceDetails">
            <summary>Provides optional service resolution details: service key, required service type, what return when service is unresolved,
            default value if service is unresolved, custom service value.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.Default">
            Default details if not specified, use default setting values, e.g. <see cref="F:DryIoc.IfUnresolved.Throw"/>
        </member>
        <member name="F:DryIoc.ServiceDetails.IfUnresolvedReturnDefault">
            Default details with <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/> option.
        </member>
        <member name="F:DryIoc.ServiceDetails.IfUnresolvedReturnDefaultIfNotRegistered">
            Default details with <see cref="F:DryIoc.IfUnresolved.ReturnDefaultIfNotRegistered"/> option.
        </member>
        <member name="M:DryIoc.ServiceDetails.Of(System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Creates new details out of provided settings, or returns default if all settings have default value.</summary>
        </member>
        <member name="M:DryIoc.ServiceDetails.Of(System.Object)">
            <summary>Sets custom value for service. This setting is orthogonal to the rest.
            Using default value with invalid ifUnresolved.Throw option to indicate custom value.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.RequiredServiceType">
            <summary>Service type to search in registry. Should be assignable to user requested service type.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.ServiceKey">
            <summary>Service key provided with registration.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.MetadataKey">
            <summary>Metadata key to find in metadata dictionary in resolved service.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.Metadata">
            <summary>Metadata value to find in resolved service.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.IfUnresolved">
            <summary>Policy to deal with unresolved request.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.HasCustomValue">
            <summary>Indicates that the custom value is specified.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails._value">
            <summary>Either default or custom value depending on <see cref="F:DryIoc.ServiceDetails.IfUnresolved"/> setting.</summary>
        </member>
        <member name="P:DryIoc.ServiceDetails.DefaultValue">
            <summary>Value to use in case <see cref="F:DryIoc.ServiceDetails.IfUnresolved"/> is set to not Throw.</summary>
        </member>
        <member name="P:DryIoc.ServiceDetails.CustomValue">
            <summary>Custom value specified for dependency. The IfUnresolved.Throw is the marker of custom value comparing to default value.</summary>
        </member>
        <member name="M:DryIoc.ServiceDetails.ToString">
            <summary>Pretty prints service details to string for debugging and errors.</summary> <returns>Details string.</returns>
        </member>
        <member name="T:DryIoc.ServiceInfoTools">
            <summary>Contains tools for combining or propagating of <see cref="T:DryIoc.IServiceInfo"/> independent of its concrete implementations.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.With(DryIoc.IServiceInfo,System.Type)">
            <summary>Creates service info with new type but keeping the details.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.WithIfUnresolved(DryIoc.IServiceInfo,DryIoc.IfUnresolved)">
            <summary>Creates new info with new IfUnresolved behavior or returns the original info if behavior is not different,
            or the passed info is not a <see cref="F:DryIoc.ServiceDetails.HasCustomValue"/>.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.WithDetails``1(``0,DryIoc.ServiceDetails)">
            <summary>Combines service info with details. The main goal is to combine service and required service type.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.InheritInfoFromDependencyOwner(DryIoc.IServiceInfo,DryIoc.IServiceInfo,DryIoc.IContainer,DryIoc.FactoryType)">
            <summary>Enables propagation/inheritance of info between dependency and its owner:
            for instance <see cref="F:DryIoc.ServiceDetails.RequiredServiceType"/> for wrappers.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.GetActualServiceType(DryIoc.IServiceInfo)">
            <summary>Returns required service type if it is specified and assignable to service type,
            otherwise returns service type.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.Print(System.Text.StringBuilder,DryIoc.IServiceInfo)">
            <summary>Appends info string representation into provided builder.</summary>
        </member>
        <member name="T:DryIoc.ServiceInfo">
            <summary>Represents custom or resolution root service info, there is separate representation for parameter,
            property and field dependencies.</summary>
        </member>
        <member name="F:DryIoc.ServiceInfo.Empty">
            <summary>Empty service info for convenience.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of(System.Type,DryIoc.IfUnresolved,System.Object)">
            <summary>Creates info out of provided settings</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of(System.Type,System.Type,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Creates info out of provided settings</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of``1(DryIoc.IfUnresolved,System.Object)">
            <summary>Creates service info using typed <typeparamref name="TService"/>.</summary>
        </member>
        <member name="T:DryIoc.ServiceInfo.Typed`1">
            <summary>Strongly-typed version of Service Info.</summary> <typeparam name="TService">Service type.</typeparam>
        </member>
        <member name="M:DryIoc.ServiceInfo.Typed`1.#ctor">
            <summary>Creates service info object.</summary>
        </member>
        <member name="P:DryIoc.ServiceInfo.ServiceType">
            <summary>Type of service to create. Indicates registered service in registry.</summary>
        </member>
        <member name="P:DryIoc.ServiceInfo.ServiceKey">
            <summary>Shortcut access to service key</summary>
        </member>
        <member name="P:DryIoc.ServiceInfo.Details">
            <summary>Additional settings. If not specified uses <see cref="F:DryIoc.ServiceDetails.Default"/>.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.ToString">
            <summary>Prints info to string using <see cref="M:DryIoc.ServiceInfoTools.Print(System.Text.StringBuilder,DryIoc.IServiceInfo)"/>.</summary> <returns>Printed string.</returns>
        </member>
        <member name="T:DryIoc.ParameterServiceInfo">
            <summary>Provides <see cref="T:DryIoc.IServiceInfo"/> for parameter,
            by default using parameter name as <see cref="P:DryIoc.IServiceInfo.ServiceType"/>.</summary>
            <remarks>For parameter default setting <see cref="F:DryIoc.ServiceDetails.IfUnresolved"/> is <see cref="F:DryIoc.IfUnresolved.Throw"/>.</remarks>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.Of(System.Reflection.ParameterInfo)">
            <summary>Creates service info from parameter alone, setting service type to parameter type,
            and setting resolution policy to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/> if parameter is optional.</summary>
        </member>
        <member name="F:DryIoc.ParameterServiceInfo.DereferencedParameterType">
            <summary>The parameter type or dereferenced parameter type for `ref`, `in`, `out` parameters</summary>
        </member>
        <member name="P:DryIoc.ParameterServiceInfo.ServiceType">
            <summary>Service type specified by <see cref="P:System.Reflection.ParameterInfo.ParameterType"/>.</summary>
        </member>
        <member name="P:DryIoc.ParameterServiceInfo.Details">
            <summary>Optional service details.</summary>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
        </member>
        <member name="F:DryIoc.ParameterServiceInfo.Parameter">
            <summary>Parameter info.</summary>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.ToString">
            <summary>Prints info to string using <see cref="M:DryIoc.ServiceInfoTools.Print(System.Text.StringBuilder,DryIoc.IServiceInfo)"/>.</summary> <returns>Printed string.</returns>
        </member>
        <member name="T:DryIoc.PropertyOrFieldServiceInfo">
            <summary>Base class for property and field dependency info.</summary>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.Of(System.Reflection.MemberInfo)">
            <summary>Create member info out of provide property or field.</summary>
            <param name="member">Member is either property or field.</param> <returns>Created info.</returns>
        </member>
        <member name="P:DryIoc.PropertyOrFieldServiceInfo.ServiceType">
            <summary>The required service type. It will be either <see cref="P:System.Reflection.FieldInfo.FieldType"/> or <see cref="P:System.Reflection.PropertyInfo.PropertyType"/>.</summary>
        </member>
        <member name="P:DryIoc.PropertyOrFieldServiceInfo.Details">
            <summary>Optional details: service key, if-unresolved policy, required service type.</summary>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
            <param name="serviceType">Required service type.</param> <param name="details">Optional details.</param> <returns>Create info.</returns>
        </member>
        <member name="P:DryIoc.PropertyOrFieldServiceInfo.Member">
            <summary>Either <see cref="T:System.Reflection.PropertyInfo"/> or <see cref="T:System.Reflection.FieldInfo"/>.</summary>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.SetValue(System.Object,System.Object)">
            <summary>Sets property or field value on provided holder object.</summary>
            <param name="holder">Holder of property or field.</param> <param name="value">Value to set.</param>
        </member>
        <member name="T:DryIoc.RequestFlags">
            <summary>Stored check results of two kinds: inherited down dependency chain and not.</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.TracksTransientDisposable">
            <summary>Not inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsSingletonOrDependencyOfSingleton">
            <summary>Inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsWrappedInFunc">
            <summary>Inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsResolutionCall">
            <summary>Indicates that the request is the one from Resolve call.</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.OpensResolutionScope">
            <summary>Non inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.StopRecursiveDependencyCheck">
            <summary>Non inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsGeneratedResolutionDependencyExpression">
            <summary>Non inherited. Marks the expression to be added to generated resolutions to prevent infinite recursion</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsDirectlyWrappedInFunc">
            <summary>Non inherited. Indicates the root service inside the function.</summary>
        </member>
        <member name="T:DryIoc.RequestTools">
            Helper extension methods to use on the bunch of factories instead of lambdas to minimize allocations
        </member>
        <member name="T:DryIoc.Request">
            <summary>Tracks the requested service and resolved factory details in a chain of nested dependencies.</summary>
        </member>
        <member name="F:DryIoc.Request.Empty">
            <summary>Empty terminal request.</summary>
        </member>
        <member name="F:DryIoc.Request.EmptyOpensResolutionScope">
            <summary>Empty request which opens resolution scope.</summary>
        </member>
        <member name="M:DryIoc.Request.Create(DryIoc.IContainer,DryIoc.IServiceInfo,DryIoc.Request,DryIoc.RequestFlags,System.Object[])">
            <summary>Creates the Resolve request. The container initiated the Resolve is stored within request.</summary>
        </member>
        <member name="M:DryIoc.Request.Create(DryIoc.IContainer,System.Type,System.Object,DryIoc.IfUnresolved,System.Type,DryIoc.Request,DryIoc.RequestFlags,System.Object[])">
            <summary>Creates the Resolve request. The container initiated the Resolve is stored within request.</summary>
        </member>
        <member name="F:DryIoc.Request.Container">
            <summary>Available in runtime only, provides access to container initiated the request.</summary>
        </member>
        <member name="F:DryIoc.Request.DirectParent">
            <summary>Request immediate parent.</summary>
        </member>
        <member name="F:DryIoc.Request.Flags">
            <summary>Persisted request conditions</summary>
        </member>
        <member name="F:DryIoc.Request._serviceInfo">
            mutable, so that the ServiceKey or IfUnresolved can be changed in place.
        </member>
        <member name="F:DryIoc.Request.InputArgExprs">
            <summary>Input arguments provided with `Resolve`</summary>
        </member>
        <member name="F:DryIoc.Request.Factory">
            <summary>Runtime known resolve factory, otherwise is <c>null</c></summary>
        </member>
        <member name="P:DryIoc.Request.FactoryID">
            <summary>Resolved factory ID, used to identify applied decorator.</summary>
        </member>
        <member name="P:DryIoc.Request.FactoryType">
            <summary>Type of factory: Service, Wrapper, or Decorator.</summary>
        </member>
        <member name="M:DryIoc.Request.CombineDecoratorWithDecoratedFactoryID">
            <summary>Combines decorator and <see cref="P:DryIoc.Request.DecoratedFactoryID"/></summary>
        </member>
        <member name="P:DryIoc.Request.ImplementationType">
            <summary>Service implementation type if known.</summary>
        </member>
        <member name="P:DryIoc.Request.Reuse">
            <summary>Service reuse.</summary>
        </member>
        <member name="P:DryIoc.Request.DecoratedFactoryID">
            <summary>ID of decorated factory in case of decorator factory type</summary>
        </member>
        <member name="F:DryIoc.Request.DependencyDepth">
            <summary>Number of nested dependencies. Set with each new Push.</summary>
        </member>
        <member name="F:DryIoc.Request.DependencyCount">
            <summary>The total dependency count</summary>
        </member>
        <member name="P:DryIoc.Request.IsEmpty">
            <summary>Indicates that request is empty initial request.</summary>
        </member>
        <member name="P:DryIoc.Request.IsResolutionRoot">
            <summary>Returns true if request is First in First Resolve call.</summary>
        </member>
        <member name="P:DryIoc.Request.IsResolutionCall">
            <summary>Returns true if request is First in Resolve call.</summary>
        </member>
        <member name="P:DryIoc.Request.IsNestedResolutionCall">
            <summary>Not the root resolution call.</summary>
        </member>
        <member name="P:DryIoc.Request.OpensResolutionScope">
            <summary>Returns true if request is First in First Resolve call.</summary>
        </member>
        <member name="M:DryIoc.Request.IsWrappedInFunc">
            <summary>Checks if the request Or its parent is wrapped in Func.
            Use <see cref="M:DryIoc.Request.IsDirectlyWrappedInFunc"/> for the direct Func wrapper.</summary>
        </member>
        <member name="M:DryIoc.Request.IsDirectlyWrappedInFunc">
            <summary>Checks if the request is directly wrapped in Func</summary>
        </member>
        <member name="M:DryIoc.Request.IsWrappedInFuncWithArgs">
            <summary>Checks if request has parent with service type of Func with arguments.</summary>
        </member>
        <member name="M:DryIoc.Request.GetInputArgsExpr">
            <summary>Returns expression for func arguments.</summary>
        </member>
        <member name="P:DryIoc.Request.TracksTransientDisposable">
            <summary>Indicates that requested service is transient disposable that should be tracked.</summary>
        </member>
        <member name="P:DryIoc.Request.IsSingletonOrDependencyOfSingleton">
            <summary>Indicates the request is singleton or has singleton upper in dependency chain.</summary>
        </member>
        <member name="M:DryIoc.Request.ShouldSplitObjectGraph">
            <summary>Is not used</summary>
        </member>
        <member name="P:DryIoc.Request.CurrentScope">
            <summary>Current scope</summary>
        </member>
        <member name="P:DryIoc.Request.SingletonScope">
            <summary>Singletons</summary>
        </member>
        <member name="P:DryIoc.Request.Rules">
            <summary>Shortcut to issued container rules.</summary>
        </member>
        <member name="P:DryIoc.Request.Made">
            <summary>(optional) Made spec used for resolving request.</summary>
        </member>
        <member name="P:DryIoc.Request.Parent">
            <summary>Returns service parent skipping wrapper if any. To get direct parent use <see cref="F:DryIoc.Request.DirectParent"/>.</summary>
        </member>
        <member name="P:DryIoc.Request.ServiceType">
            <summary>Requested service type.</summary>
        </member>
        <member name="M:DryIoc.Request.GetActualServiceType">
            <summary>Compatible required or service type.</summary>
        </member>
        <member name="P:DryIoc.Request.ServiceKey">
            <summary>Optional service key to identify service of the same type.</summary>
        </member>
        <member name="P:DryIoc.Request.MetadataKey">
            <summary>Metadata key to find in metadata dictionary in resolved service.</summary>
        </member>
        <member name="P:DryIoc.Request.Metadata">
            <summary>Metadata or the value (if key specified) to find in resolved service.</summary>
        </member>
        <member name="P:DryIoc.Request.IfUnresolved">
            <summary>Policy to deal with unresolved service.</summary>
        </member>
        <member name="P:DryIoc.Request.RequiredServiceType">
            <summary>Required service type if specified.</summary>
        </member>
        <member name="P:DryIoc.Request.ReuseLifespan">
            <summary>Relative number representing reuse lifespan.</summary>
        </member>
        <member name="M:DryIoc.Request.GetKnownImplementationOrServiceType">
            <summary>Known implementation, or otherwise actual service type.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(DryIoc.IServiceInfo,DryIoc.RequestFlags)">
            <summary>Creates new request with provided info, and links current request as a parent.
            Allows to set some additional flags. Existing/parent request should be resolved to 
            factory via `WithResolvedFactory` before pushing info into it.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Object,DryIoc.IfUnresolved,System.Type,DryIoc.RequestFlags)">
            <summary>Composes service description into <see cref="T:DryIoc.IServiceInfo"/> and Pushes the new request.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Int32,System.Type,DryIoc.IReuse)">
            <summary>Creates info by supplying all the properties and chaining it with current (parent) info.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Type,System.Object,System.Int32,DryIoc.FactoryType,System.Type,DryIoc.IReuse,DryIoc.RequestFlags)">
            <summary>Creates info by supplying all the properties and chaining it with current (parent) info.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Type,System.Object,DryIoc.IfUnresolved,System.Int32,DryIoc.FactoryType,System.Type,DryIoc.IReuse,DryIoc.RequestFlags,System.Int32)">
            <summary>Creates info by supplying all the properties and chaining it with current (parent) info.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Type,System.Object,System.String,System.Object,DryIoc.IfUnresolved,System.Int32,DryIoc.FactoryType,System.Type,DryIoc.IReuse,DryIoc.RequestFlags,System.Int32)">
            <summary>Creates info by supplying all the properties and chaining it with current (parent) info.</summary>
        </member>
        <member name="M:DryIoc.Request.WithChangedServiceInfo(System.Func{DryIoc.IServiceInfo,DryIoc.IServiceInfo})">
            <summary>Allow to switch current service info to the new one, e.g. in decorators.
            If info did not change then return the same this request.</summary>
        </member>
        <member name="M:DryIoc.Request.WithIfUnresolved(DryIoc.IfUnresolved)">
            Produces the new request with the changed `ifUnresolved` or returns original request otherwise
        </member>
        <member name="M:DryIoc.Request.WithFlags(DryIoc.RequestFlags)">
            <summary>Updates the flags</summary>
        </member>
        <member name="M:DryIoc.Request.ChangeServiceKey(System.Object)">
            <summary>Sets service key to passed value. Required for multiple default services to change null key to
            actual <see cref="T:DryIoc.DefaultKey"/></summary>
        </member>
        <member name="M:DryIoc.Request.WithInputArgs(System.Linq.Expressions.Expression[])">
            <summary>Prepends input arguments to existing arguments in request. It is done because the
            nested Func/Action input argument has a priority over outer argument.
            The arguments are provided by Func and Action wrappers, or by `args` parameter in Resolve call.</summary>
        </member>
        <member name="M:DryIoc.Request.WithResolvedFactory(DryIoc.Factory,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Returns new request with set implementation details.</summary>
            <param name="factory">Factory to which request is resolved.</param>
            <param name="skipRecursiveDependencyCheck">(optional) does not check for recursive dependency.
            Use with caution. Make sense for Resolution expression.</param>
            <param name="skipCaptiveDependencyCheck">(optional) allows to skip reuse mismatch aka captive dependency check.</param>
            <param name="copyRequest">Make a defensive copy of request.</param>
            <returns>New request with set factory.</returns>
        </member>
        <member name="M:DryIoc.Request.HasRecursiveParent(System.Int32)">
            <summary>Check for the parents.</summary>
        </member>
        <member name="M:DryIoc.Request.Is``1(System.Func{``0},System.Func{System.Reflection.ParameterInfo,``0},System.Func{System.Reflection.PropertyInfo,``0},System.Func{System.Reflection.FieldInfo,``0})">
            <summary>If request corresponds to dependency injected into parameter,
            then method calls <paramref name="parameter"/> handling and returns its result.
            If request corresponds to property or field, then method calls respective handler.
            If request does not correspond to dependency, then calls <paramref name="root"/> handler.</summary>
        </member>
        <member name="M:DryIoc.Request.Enumerate">
            <summary>Obsolete: now request is directly implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
        </member>
        <member name="M:DryIoc.Request.GetEnumerator">
            <summary>Enumerates self and all request stack parents.</summary>
        </member>
        <member name="M:DryIoc.Request.PrintCurrent(System.Text.StringBuilder)">
            <summary>Prints current request info only (no parents printed) to provided builder.</summary>
        </member>
        <member name="M:DryIoc.Request.Print(System.Int32)">
            <summary>Prints full stack of requests starting from current one using <see cref="M:DryIoc.Request.PrintCurrent(System.Text.StringBuilder)"/>.</summary>
        </member>
        <member name="M:DryIoc.Request.ToString">
            <summary>Prints whole request chain.</summary>
        </member>
        <member name="M:DryIoc.Request.Equals(System.Object)">
            <summary>Returns true if request info and passed object are equal, and their parents recursively are equal.</summary>
        </member>
        <member name="M:DryIoc.Request.Equals(DryIoc.Request)">
            <summary>Returns true if request info and passed info are equal, and their parents recursively are equal.</summary>
        </member>
        <member name="M:DryIoc.Request.EqualsWithoutParent(DryIoc.Request)">
            <summary>Compares self properties but not the parents.</summary>
        </member>
        <member name="M:DryIoc.Request.GetHashCode">
            <summary>Calculates the combined hash code based on factory IDs.</summary>
        </member>
        <member name="M:DryIoc.Request.IsolateRequestChain">
            Severe the connection with the request pool up to the parent so that noone can change the Request state
        </member>
        <member name="T:DryIoc.FactoryType">
            <summary>Type of services supported by Container.</summary>
        </member>
        <member name="F:DryIoc.FactoryType.Service">
            <summary>(default) Defines normal service factory</summary>
        </member>
        <member name="F:DryIoc.FactoryType.Decorator">
            <summary>Defines decorator factory</summary>
        </member>
        <member name="F:DryIoc.FactoryType.Wrapper">
            <summary>Defines wrapper factory.</summary>
        </member>
        <member name="T:DryIoc.Setup">
            <summary>Base class to store optional <see cref="T:DryIoc.Factory"/> settings.</summary>
        </member>
        <member name="P:DryIoc.Setup.FactoryType">
            <summary>Factory type is required to be specified by concrete setups as in
            <see cref="T:DryIoc.Setup.ServiceSetup"/>, <see cref="T:DryIoc.Setup.DecoratorSetup"/>, <see cref="T:DryIoc.Setup.WrapperSetup"/>.</summary>
        </member>
        <member name="P:DryIoc.Setup.Condition">
            <summary>Predicate to check if factory could be used for resolved request.</summary>
        </member>
        <member name="P:DryIoc.Setup.DisposalOrder">
            <summary>Relative disposal order when defined. Greater number, later dispose.</summary>
        </member>
        <member name="P:DryIoc.Setup.Metadata">
            <summary>Arbitrary metadata object associated with Factory/Implementation, may be a dictionary of key-values.</summary>
        </member>
        <member name="M:DryIoc.Setup.MatchesMetadata(System.String,System.Object)">
            <summary>Returns true if passed meta key and value match the setup metadata.</summary>
        </member>
        <member name="P:DryIoc.Setup.AsResolutionCall">
            <summary>Indicates that injected expression should be:
            <c><![CDATA[r.Resolver.Resolve<IDependency>(...)]]></c>
            instead of: <c><![CDATA[new Dependency(...)]]></c></summary>
        </member>
        <member name="F:DryIoc.Setup.AsResolutionCallSetup">
            Setup with the only setting: `AsResolutionCall` 
        </member>
        <member name="P:DryIoc.Setup.AsResolutionCallForExpressionGeneration">
            <summary>Works as `AsResolutionCall` but only with `Rules.UsedForExpressionGeneration`</summary>
        </member>
        <member name="F:DryIoc.Setup.AsResolutionCallForGeneratedExpressionSetup">
            <summary>Specifies to use `asResolutionCall` but only in expression generation context, e.g. for compile-time generation</summary>
        </member>
        <member name="P:DryIoc.Setup.AsResolutionRoot">
            <summary>Marks service (not a wrapper or decorator) registration that is expected to be resolved via Resolve call.</summary>
        </member>
        <member name="P:DryIoc.Setup.OpenResolutionScope">
            <summary>Opens scope, also implies <see cref="P:DryIoc.Setup.AsResolutionCall"/>.</summary>
        </member>
        <member name="P:DryIoc.Setup.WeaklyReferenced">
            <summary>Stores reused instance as WeakReference.</summary>
        </member>
        <member name="P:DryIoc.Setup.AllowDisposableTransient">
            <summary>Allows registering transient disposable.</summary>
        </member>
        <member name="P:DryIoc.Setup.TrackDisposableTransient">
            <summary>Turns On tracking of disposable transient dependency in parent scope or in open scope if resolved directly.</summary>
        </member>
        <member name="P:DryIoc.Setup.UseParentReuse">
            <summary>Instructs to use parent reuse. Applied only if <see cref="P:DryIoc.Factory.Reuse"/> is not specified.</summary>
        </member>
        <member name="P:DryIoc.Setup.PreventDisposal">
            <summary>Prevents disposal of reused instance if it is disposable.</summary>
        </member>
        <member name="P:DryIoc.Setup.PreferInSingleServiceResolve">
            <summary>When single service is resolved, but multiple candidates found, this options will be used to prefer this one.</summary>
        </member>
        <member name="F:DryIoc.Setup.Default">
            <summary>Default setup for service factories.</summary>
        </member>
        <member name="M:DryIoc.Setup.With(System.Object,System.Func{DryIoc.Request,System.Boolean},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Boolean)">
            <summary>Constructs setup object out of specified settings.
            If all settings are default then <see cref="F:DryIoc.Setup.Default"/> setup will be returned.
            <paramref name="metadataOrFuncOfMetadata"/> is metadata object or Func returning metadata object.</summary>
        </member>
        <member name="F:DryIoc.Setup.Wrapper">
            <summary>Default setup which will look for wrapped service type as single generic parameter.</summary>
        </member>
        <member name="M:DryIoc.Setup.WrapperWith(System.Int32,System.Boolean,System.Func{System.Type,System.Type},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Func{DryIoc.Request,System.Boolean},System.Int32)">
            <summary>Returns generic wrapper setup.
            Default for <paramref name="wrappedServiceTypeArgIndex" /> is -1 for generic wrapper with single type argument.
            Index need to be set for multiple type arguments. <paramref name="alwaysWrapsRequiredServiceType" /> need to be set 
            when generic wrapper type arguments should be ignored.</summary>
        </member>
        <member name="F:DryIoc.Setup.Decorator">
            <summary>Default decorator setup: decorator is applied to service type it registered with.</summary>
        </member>
        <member name="M:DryIoc.Setup.DecoratorWith(System.Func{DryIoc.Request,System.Boolean},System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>Creates setup with optional condition.
            The <paramref name="order" /> specifies relative decorator position in decorators chain.
            Greater number means further from decoratee - specify negative number to stay closer.
            Decorators without order (Order is 0) or with equal order are applied in registration order
            - first registered are closer decoratee.</summary>
        </member>
        <member name="M:DryIoc.Setup.GetDecorateeCondition(System.Type,System.Object,System.Func{DryIoc.Request,System.Boolean})">
            Creates a condition for both <paramref name="decorateeType"/>, <paramref name="decorateeServiceKey"/> and additional condition
        </member>
        <member name="M:DryIoc.Setup.DecoratorOf(System.Type,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Object)">
            <summary>Setup for decorator of type <paramref name="decorateeType"/>.</summary>
        </member>
        <member name="M:DryIoc.Setup.DecoratorOf``1(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Object)">
            <summary>Setup for decorator of type <typeparamref name="TDecoratee"/>.</summary>
        </member>
        <member name="T:DryIoc.Setup.ServiceSetup">
            <summary>Service setup.</summary>
        </member>
        <member name="P:DryIoc.Setup.ServiceSetup.FactoryType">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.Setup.ServiceSetup.Metadata">
            <summary>Evaluates metadata if it specified as Func of object, and replaces Func with its result!.
            Otherwise just returns metadata object.</summary>
            <remarks>Invocation of Func metadata is Not thread-safe. Please take care of that inside the Func.</remarks>
        </member>
        <member name="M:DryIoc.Setup.ServiceSetup.#ctor">
            All settings are set to defaults.
        </member>
        <member name="M:DryIoc.Setup.ServiceSetup.#ctor(System.Func{DryIoc.Request,System.Boolean},System.Object,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Boolean,System.Boolean)">
            Specify all the individual settings.
        </member>
        <member name="T:DryIoc.Setup.WrapperSetup">
            <summary>Setup applied for wrappers.</summary>
        </member>
        <member name="P:DryIoc.Setup.WrapperSetup.FactoryType">
            <summary>Returns <see cref="F:DryIoc.FactoryType.Wrapper"/> type.</summary>
        </member>
        <member name="F:DryIoc.Setup.WrapperSetup.WrappedServiceTypeArgIndex">
            <summary>Delegate to get wrapped type from provided wrapper type.
            If wrapper is generic, then wrapped type is usually a generic parameter.</summary>
        </member>
        <member name="F:DryIoc.Setup.WrapperSetup.AlwaysWrapsRequiredServiceType">
            <summary>Per name.</summary>
        </member>
        <member name="F:DryIoc.Setup.WrapperSetup.Unwrap">
            <summary>Delegate returning wrapped type from wrapper type. Overwrites other options.</summary>
        </member>
        <member name="M:DryIoc.Setup.WrapperSetup.#ctor(System.Int32)">
            <summary>Default setup</summary>
            <param name="wrappedServiceTypeArgIndex">Default is -1 for generic wrapper with single type argument.
            Need to be set for multiple type arguments.</param>
        </member>
        <member name="M:DryIoc.Setup.WrapperSetup.#ctor(System.Int32,System.Boolean,System.Func{System.Type,System.Type},System.Func{DryIoc.Request,System.Boolean},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>Returns generic wrapper setup.
            Default for <paramref name="wrappedServiceTypeArgIndex" /> is -1 for generic wrapper with single type argument.
            Index need to be set for multiple type arguments. <paramref name="alwaysWrapsRequiredServiceType" /> need to be set 
            when generic wrapper type arguments should be ignored.</summary>
        </member>
        <member name="M:DryIoc.Setup.WrapperSetup.GetWrappedTypeOrNullIfWrapsRequired(System.Type)">
            <summary>Unwraps service type or returns the <paramref name="serviceType"/> as-is.</summary>
        </member>
        <member name="T:DryIoc.Setup.DecoratorSetup">
            <summary>Setup applied to decorators.</summary>
        </member>
        <member name="P:DryIoc.Setup.DecoratorSetup.FactoryType">
            <summary>Returns Decorator factory type.</summary>
        </member>
        <member name="F:DryIoc.Setup.DecoratorSetup.Order">
            <summary>If provided specifies relative decorator position in decorators chain.
            Greater number means further from decoratee - specify negative number to stay closer.
            Decorators without order (Order is 0) or with equal order are applied in registration order
            - first registered are closer decoratee.</summary>
        </member>
        <member name="F:DryIoc.Setup.DecoratorSetup.UseDecorateeReuse">
            <summary>Instructs to use decorated service reuse. Decorated service may be decorator itself.</summary>
        </member>
        <member name="M:DryIoc.Setup.DecoratorSetup.#ctor">
            <summary>Default setup.</summary>
        </member>
        <member name="M:DryIoc.Setup.DecoratorSetup.#ctor(System.Func{DryIoc.Request,System.Boolean},System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>Creates decorator setup with optional condition. <paramref name="condition" /> applied to 
            decorated service to find that service is the decorator target. <paramref name="order" /> specifies 
            relative decorator position in decorators chain. Greater number means further from decoratee -
            specify negative number to stay closer. Decorators without order (Order is 0) or with equal order
            are applied in registration order - first registered are closer decoratee.</summary>
        </member>
        <member name="T:DryIoc.IConcreteFactoryGenerator">
            <summary>Facility for creating concrete factories from some template/prototype. Example:
            creating closed-generic type reflection factory from registered open-generic prototype factory.</summary>
        </member>
        <member name="P:DryIoc.IConcreteFactoryGenerator.GeneratedFactories">
            <summary>Generated factories so far, identified by the service type and key pair.</summary>
        </member>
        <member name="M:DryIoc.IConcreteFactoryGenerator.GetGeneratedFactory(DryIoc.Request,System.Boolean)">
            <summary>Returns factory per request. May track already generated factories and return one without regenerating.</summary>
        </member>
        <member name="T:DryIoc.FactoryCaching">
            Instructs how to deal with factory result expression: 
        </member>
        <member name="F:DryIoc.FactoryCaching.Default">
            Is up to DryIoc to decide,
        </member>
        <member name="F:DryIoc.FactoryCaching.PleaseDontSetDoNotCache">
            Prevents DryIoc to set `DoNotCache`.
        </member>
        <member name="F:DryIoc.FactoryCaching.DoNotCache">
            If set, the expression won't be cached 
        </member>
        <member name="T:DryIoc.Factory">
            <summary>Base class for different ways to instantiate service:
            <list type="bullet">
            <item>Through reflection - <see cref="T:DryIoc.ReflectionFactory"/></item>
            <item>Using custom delegate - <see cref="T:DryIoc.DelegateFactory"/></item>
            <item>Using custom expression - <see cref="T:DryIoc.ExpressionFactory"/></item>
            <item>A placeholder for future actual implementation - <see cref="T:DryIoc.FactoryPlaceholder"/></item>
            </list>
            For all of the types Factory should provide result as <see cref="T:System.Linq.Expressions.Expression"/> and <see cref="T:DryIoc.FactoryDelegate"/>.
            Factories are supposed to be immutable and stateless.
            Each created factory has an unique ID set in <see cref="P:DryIoc.Factory.FactoryID"/>.</summary>
        </member>
        <member name="M:DryIoc.Factory.GetNextID">
            <summary>Get next factory ID in a atomic way.</summary><returns>The ID.</returns>
        </member>
        <member name="P:DryIoc.Factory.FactoryID">
            <summary>Unique factory id generated from static seed.</summary>
        </member>
        <member name="P:DryIoc.Factory.Reuse">
            <summary>Reuse policy for created services.</summary>
        </member>
        <member name="P:DryIoc.Factory.Setup">
            <summary>Setup may contain different/non-default factory settings.</summary>
        </member>
        <member name="M:DryIoc.Factory.CheckCondition(DryIoc.Request)">
            <summary>Checks that condition is met for request or there is no condition setup.</summary>
        </member>
        <member name="P:DryIoc.Factory.FactoryType">
            <summary>Shortcut for <see cref="P:DryIoc.Setup.FactoryType"/>.</summary>
        </member>
        <member name="P:DryIoc.Factory.ImplementationType">
            <summary>Non-abstract closed implementation type. May be null if not known beforehand, e.g. in <see cref="T:DryIoc.DelegateFactory"/>.</summary>
        </member>
        <member name="P:DryIoc.Factory.CanAccessImplementationType">
            <summary>Allow inheritors to define lazy implementation type</summary>
        </member>
        <member name="P:DryIoc.Factory.FactoryGenerator">
            <summary>Indicates that Factory is factory provider and
            consumer should call <see cref="M:DryIoc.IConcreteFactoryGenerator.GetGeneratedFactory(DryIoc.Request,System.Boolean)"/> to get concrete factory.</summary>
        </member>
        <member name="P:DryIoc.Factory.RegistrationOrder">
            <summary>Registration order.</summary>
        </member>
        <member name="P:DryIoc.Factory.Made">
            <summary>Settings <b>(if any)</b> to select Constructor/FactoryMethod, Parameters, Properties and Fields.</summary>
        </member>
        <member name="P:DryIoc.Factory.HasRuntimeState">
            <summary>The factory inserts the runtime-state into result expression, e.g. delegate or pre-created instance.</summary>
        </member>
        <member name="P:DryIoc.Factory.Caching">
            Indicates how to deal with the result expression
        </member>
        <member name="M:DryIoc.Factory.DoNotCache">
            Instructs to skip caching the factory unless it really wants to do so via `PleaseDontSetDoNotCache`
        </member>
        <member name="M:DryIoc.Factory.#ctor(DryIoc.IReuse,DryIoc.Setup)">
            <summary>Initializes reuse and setup. Sets the <see cref="P:DryIoc.Factory.FactoryID"/></summary>
            <param name="reuse">(optional)</param> <param name="setup">(optional)</param>
        </member>
        <member name="M:DryIoc.Factory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>The main factory method to create service expression, e.g. "new Client(new Service())".
            If <paramref name="request"/> has <see cref="F:DryIoc.Request.InputArgExprs"/> specified, they could be used in expression.</summary>
            <param name="request">Service request.</param>
            <returns>Created expression.</returns>
        </member>
        <member name="M:DryIoc.Factory.GetExpressionOrDefault(DryIoc.Request)">
            <summary>Returns service expression: either by creating it with <see cref="M:DryIoc.Factory.CreateExpressionOrDefault(DryIoc.Request)"/> or taking expression from cache.
            Before returning method may transform the expression  by applying <see cref="P:DryIoc.Factory.Reuse"/>, or/and decorators if found any.</summary>
        </member>
        <member name="M:DryIoc.Factory.ApplyReuse(System.Linq.Expressions.Expression,DryIoc.Request)">
            <summary>Applies reuse to created expression, by wrapping passed expression into scoped access
            and producing the result expression.</summary>
        </member>
        <member name="M:DryIoc.Factory.UseInterpretation(DryIoc.Request)">
            [Obsolete("Not need to control on the factory level, the remaining UseInstanceFactory will be removed")] 
        </member>
        <member name="M:DryIoc.Factory.GetDelegateOrDefault(DryIoc.Request)">
            Creates factory delegate from service expression and returns it.
        </member>
        <member name="M:DryIoc.Factory.ToString">
            <summary>Returns nice string representation of factory.</summary>
        </member>
        <member name="T:DryIoc.FactoryMethodSelector">
            <summary>Declares delegate to get single factory method or constructor for resolved request.</summary>
        </member>
        <member name="T:DryIoc.ParameterSelector">
            <summary>Specifies how to get parameter info for injected parameter and resolved request</summary>
        </member>
        <member name="T:DryIoc.PropertiesAndFieldsSelector">
            <summary>Specifies what properties or fields to inject and how.</summary>
        </member>
        <member name="T:DryIoc.Parameters">
            <summary>DSL for specifying <see cref="T:DryIoc.ParameterSelector"/> injection rules.</summary>
        </member>
        <member name="F:DryIoc.Parameters.Of">
            <summary>Returns default service info wrapper for each parameter info.</summary>
        </member>
        <member name="F:DryIoc.Parameters.IfUnresolvedReturnDefault">
            <summary>Returns service info which considers each parameter as optional.</summary>
        </member>
        <member name="M:DryIoc.Parameters.OverrideWith(DryIoc.ParameterSelector,DryIoc.ParameterSelector)">
            <summary>Combines source selector with other. Other is used as fallback when source returns null.</summary>
        </member>
        <member name="M:DryIoc.Parameters.And(DryIoc.ParameterSelector,DryIoc.ParameterSelector)">
            <summary>Obsolete: please use <see cref="M:DryIoc.Parameters.OverrideWith(DryIoc.ParameterSelector,DryIoc.ParameterSelector)"/></summary>
        </member>
        <member name="M:DryIoc.Parameters.Details(DryIoc.ParameterSelector,System.Func{DryIoc.Request,System.Reflection.ParameterInfo,DryIoc.ServiceDetails})">
            <summary>Overrides source parameter rules with specific parameter details. 
            If it is not your parameter just return null.</summary>
            <param name="source">Original parameters rules</param>
            <param name="getDetailsOrNull">Should return specific details or null.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Name(DryIoc.ParameterSelector,System.String,System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for parameter identified by <paramref name="name"/>.</summary>
            <param name="source">Original parameters rules.</param> <param name="name">Name to identify parameter.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Name(DryIoc.ParameterSelector,System.String,System.Func{DryIoc.Request,System.Reflection.ParameterInfo,DryIoc.ServiceDetails})">
            <summary>Specify parameter by name and set custom value to it.</summary>
        </member>
        <member name="M:DryIoc.Parameters.Name(DryIoc.ParameterSelector,System.String,System.Func{DryIoc.Request,System.Object})">
            <summary>Specify parameter by name and set custom value to it.</summary>
        </member>
        <member name="M:DryIoc.Parameters.Type(DryIoc.ParameterSelector,System.Type,System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for parameter identified by type <paramref name="parameterType"/>.</summary>
            <param name="source">Source selector.</param> <param name="parameterType">The type of the parameter.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
            <returns>Combined selector.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Type``1(DryIoc.ParameterSelector,System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for parameter identified by type <typeparamref name="T"/>.</summary>
            <typeparam name="T">Type of parameter.</typeparam> <param name="source">Source selector.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
            <returns>Combined selector.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Type``1(DryIoc.ParameterSelector,System.Func{DryIoc.Request,System.Reflection.ParameterInfo,DryIoc.ServiceDetails})">
            <summary>Specify parameter by type and set its details.</summary>
        </member>
        <member name="M:DryIoc.Parameters.Type``1(DryIoc.ParameterSelector,System.Func{DryIoc.Request,``0})">
            <summary>Specify parameter by type and set custom value to it.</summary>
        </member>
        <member name="M:DryIoc.Parameters.Type(DryIoc.ParameterSelector,System.Type,System.Func{DryIoc.Request,System.Object})">
            <summary>Specify parameter by type and set custom value to it.</summary>
            <param name="source">Original parameters rules.</param>
            <param name="parameterType">The type of the parameter.</param>
            <param name="getCustomValue">Custom value provider.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="T:DryIoc.PropertiesAndFields">
            <summary>DSL for specifying <see cref="T:DryIoc.PropertiesAndFieldsSelector"/> injection rules.</summary>
        </member>
        <member name="F:DryIoc.PropertiesAndFields.Of">
            <summary>Say to not resolve any properties or fields.</summary>
        </member>
        <member name="F:DryIoc.PropertiesAndFields.Auto">
            <summary>Public assignable instance members of any type except object, string, primitives types, and arrays of those.</summary>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Properties(System.Boolean,System.Boolean,DryIoc.IfUnresolved)">
            <summary>Public, declared, assignable, non-primitive properties.</summary>
        </member>
        <member name="T:DryIoc.PropertiesAndFields.GetServiceInfo">
            <summary>Should return service info for input member (property or field).</summary>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.All(System.Boolean,System.Boolean,System.Boolean,System.Boolean,DryIoc.IfUnresolved,DryIoc.PropertiesAndFields.GetServiceInfo)">
            <summary>Generates selector property and field selector with settings specified by parameters.
            If all parameters are omitted the return all public not primitive members.</summary>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.OverrideWith(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Combines source properties and fields with other. Other will override the source condition.</summary>
            <param name="source">Source selector.</param> <param name="other">Specific other selector to add.</param>
            <returns>Combined result selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.And(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Obsolete: please use <see cref="M:DryIoc.PropertiesAndFields.OverrideWith(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)"/></summary>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Details(DryIoc.PropertiesAndFieldsSelector,System.String,System.Func{DryIoc.Request,DryIoc.ServiceDetails})">
            <summary>Specifies service details (key, if-unresolved policy, required type) for property/field with the name.</summary>
            <param name="source">Original member selector.</param> <param name="name">Member name.</param> <param name="getDetails">Details.</param>
            <returns>New selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Name(DryIoc.PropertiesAndFieldsSelector,System.String,System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for property/field identified by <paramref name="name"/>.</summary>
            <param name="source">Source selector.</param> <param name="name">Name to identify member.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default returns default value if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
            <returns>Combined selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Name(DryIoc.PropertiesAndFieldsSelector,System.String,System.Func{DryIoc.Request,System.Object})">
            <summary>Specifies custom value for property/field with specific name.</summary>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.IsInjectable(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>Returns true if property matches flags provided.</summary>
            <param name="property">Property to match</param>
            <param name="withNonPublic">Says to include non public properties.</param>
            <param name="withPrimitive">Says to include properties of primitive type.</param>
            <returns>True if property is matched and false otherwise.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.IsInjectable(System.Reflection.FieldInfo,System.Boolean,System.Boolean)">
            <summary>Returns true if field matches flags provided.</summary>
            <param name="field">Field to match.</param>
            <param name="withNonPublic">Says to include non public fields.</param>
            <param name="withPrimitive">Says to include fields of primitive type.</param>
            <returns>True if property is matched and false otherwise.</returns>
        </member>
        <member name="T:DryIoc.ReflectionFactory">
            <summary>Reflects on <see cref="P:DryIoc.ReflectionFactory.ImplementationType"/> constructor parameters and members,
            creates expression for each reflected dependency, and composes result service expression.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.ImplementationType">
            <summary>Non-abstract service implementation type. May be open generic.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.CanAccessImplementationType">
            <summary>False for lazy implementation type, to prevent its early materialization.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.FactoryGenerator">
            <summary>Provides closed-generic factory for registered open-generic variant.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.Made">
            <summary>Injection rules set for Constructor/FactoryMethod, Parameters, Properties and Fields.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.GeneratorFactoryID">
            <summary>FactoryID of generator (open-generic) factory.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.RegistrationOrder">
            <summary>Will contain factory ID of generator's factory for generated factory.</summary>
        </member>
        <member name="M:DryIoc.ReflectionFactory.#ctor(System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup)">
            <summary>Creates factory providing implementation type, optional reuse and setup.</summary>
            <param name="implementationType">(optional) Optional if Made.FactoryMethod is present Non-abstract close or open generic type.</param>
            <param name="reuse">(optional)</param> <param name="made">(optional)</param> <param name="setup">(optional)</param>
        </member>
        <member name="M:DryIoc.ReflectionFactory.#ctor(System.Func{System.Type},DryIoc.IReuse,DryIoc.Made,DryIoc.Setup)">
            <summary>Creates factory providing implementation type, optional reuse and setup.</summary>
            <param name="implementationTypeProvider">Provider of non-abstract closed or open-generic type.</param>
            <param name="reuse">(optional)</param> <param name="made">(optional)</param> <param name="setup">(optional)</param>
        </member>
        <member name="M:DryIoc.ReflectionFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Creates service expression.</summary>
        </member>
        <member name="T:DryIoc.ExpressionFactory">
            <summary>Creates service expression using client provided expression factory delegate.</summary>
        </member>
        <member name="M:DryIoc.ExpressionFactory.#ctor(System.Func{DryIoc.Request,System.Linq.Expressions.Expression},DryIoc.IReuse,DryIoc.Setup)">
            <summary>Wraps provided delegate into factory.</summary>
            <param name="getServiceExpression">Delegate that will be used internally to create service expression.</param>
            <param name="reuse">(optional) Reuse.</param> <param name="setup">(optional) Setup.</param>
        </member>
        <member name="M:DryIoc.ExpressionFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Creates service expression using wrapped delegate.</summary>
            <param name="request">Request to resolve.</param> <returns>Expression returned by stored delegate.</returns>
        </member>
        <member name="T:DryIoc.RegisteredInstanceFactory">
            Wraps the instance in registry
        </member>
        <member name="F:DryIoc.RegisteredInstanceFactory.Instance">
            <summary>The registered pre-created object instance</summary>
        </member>
        <member name="P:DryIoc.RegisteredInstanceFactory.ImplementationType">
            <summary>Non-abstract closed implementation type.</summary>
        </member>
        <member name="P:DryIoc.RegisteredInstanceFactory.HasRuntimeState">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.RegisteredInstanceFactory.ValidateAndNormalizeRegistration(System.Type,System.Object,System.Boolean,DryIoc.Rules)">
            Simplified specially for register instance 
        </member>
        <member name="M:DryIoc.RegisteredInstanceFactory.#ctor(System.Object,DryIoc.IReuse,DryIoc.Setup)">
            <summary>Creates factory.</summary>
        </member>
        <member name="M:DryIoc.RegisteredInstanceFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Wraps the instance in expression constant</summary>
        </member>
        <member name="M:DryIoc.RegisteredInstanceFactory.GetExpressionOrDefault(DryIoc.Request)">
            <summary>Simplified path for the registered instance</summary>
        </member>
        <member name="M:DryIoc.RegisteredInstanceFactory.GetDelegateOrDefault(DryIoc.Request)">
            <summary>Used at resolution root too simplify getting the actual instance</summary>
        </member>
        <member name="T:DryIoc.DelegateFactory">
            <summary>This factory is the thin wrapper for user provided delegate
            and where possible it uses delegate directly: without converting it to expression.</summary>
        </member>
        <member name="P:DryIoc.DelegateFactory.ImplementationType">
            <summary>Non-abstract closed implementation type.</summary>
        </member>
        <member name="P:DryIoc.DelegateFactory.HasRuntimeState">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.DelegateFactory.#ctor(DryIoc.FactoryDelegate,DryIoc.IReuse,DryIoc.Setup,System.Type)">
            <summary>Creates factory.</summary>
        </member>
        <member name="M:DryIoc.DelegateFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Create expression by wrapping call to stored delegate with provided request.</summary>
        </member>
        <member name="M:DryIoc.DelegateFactory.GetDelegateOrDefault(DryIoc.Request)">
            <summary>If possible returns delegate directly, without creating expression trees, just wrapped in <see cref="T:DryIoc.FactoryDelegate"/>.
            If decorator found for request then factory fall-backs to expression creation.</summary>
            <param name="request">Request to resolve.</param>
            <returns>Factory delegate directly calling wrapped delegate, or invoking expression if decorated.</returns>
        </member>
        <member name="T:DryIoc.CreateScopedValue">
            Should return value stored in scope
        </member>
        <member name="T:DryIoc.IScope">
            <summary>Lazy object storage that will create object with provided factory on first access,
            then will be returning the same object for subsequent access.</summary>
        </member>
        <member name="P:DryIoc.IScope.Parent">
            <summary>Parent scope in scope stack. Null for root scope.</summary>
        </member>
        <member name="P:DryIoc.IScope.Name">
            <summary>Optional name object associated with scope.</summary>
        </member>
        <member name="P:DryIoc.IScope.IsDisposed">
            <summary>True if scope is disposed.</summary>
        </member>
        <member name="M:DryIoc.IScope.TryGet(System.Object@,System.Int32)">
            <summary>Looks up for stored item by id.</summary>
        </member>
        <member name="M:DryIoc.IScope.GetOrAddViaFactoryDelegate(System.Int32,DryIoc.FactoryDelegate,DryIoc.IResolverContext,System.Int32)">
            Create the value via `FactoryDelegate` passing the `IResolverContext`
        </member>
        <member name="M:DryIoc.IScope.TryGetOrAddWithoutClosure(System.Int32,DryIoc.IResolverContext,System.Linq.Expressions.Expression,System.Boolean,System.Func{DryIoc.IResolverContext,System.Linq.Expressions.Expression,System.Boolean,System.Object},System.Int32)">
            Creates, stores, and returns created item
        </member>
        <member name="M:DryIoc.IScope.TrackDisposable(System.Object,System.Int32)">
            <summary>Tracked item will be disposed with the scope. 
            Smaller <paramref name="disposalOrder"/> will be disposed first.</summary>
        </member>
        <member name="M:DryIoc.IScope.TrackDisposableWithoutDisposalOrder``1(``0)">
            <summary>Tracked item will be disposed with the scope.</summary> 
        </member>
        <member name="M:DryIoc.IScope.SetOrAdd(System.Int32,System.Object)">
            <summary>Sets or adds the service item directly to the scope services</summary>
        </member>
        <member name="M:DryIoc.IScope.SetUsedInstance(System.Type,DryIoc.FactoryDelegate)">
            [Obsolete("Removing because it is not used")]
        </member>
        <member name="M:DryIoc.IScope.SetUsedInstance(System.Int32,System.Type,DryIoc.FactoryDelegate)">
            <summary>Sets (replaces) the factory for specified type.</summary>
        </member>
        <member name="M:DryIoc.IScope.TryGetUsedInstance(DryIoc.IResolverContext,System.Type,System.Object@)">
            Looks up for stored item by type.
        </member>
        <member name="M:DryIoc.IScope.Clone">
            <summary>Clones the scope.</summary>
        </member>
        <member name="M:DryIoc.IScope.Clone(System.Boolean)">
            <summary>The method will clone the scope factories and already created services,
            but may or may not drop the disposables thus ensuring that only the new disposables added in clone will be disposed</summary>
        </member>
        <member name="T:DryIoc.Scope">
            <summary>
            Scope is container to hold the shared per scope items and dispose <see cref="T:System.IDisposable"/> items.
            Scope uses Locking to ensure that the object factory called only once.
            </summary>
        </member>
        <member name="P:DryIoc.Scope.Parent">
            <summary>Parent scope in scope stack. Null for the root scope.</summary>
        </member>
        <member name="P:DryIoc.Scope.Name">
            <summary>Optional name associated with scope.</summary>
        </member>
        <member name="P:DryIoc.Scope.IsDisposed">
            <summary>True if scope is disposed.</summary>
        </member>
        <member name="M:DryIoc.Scope.#ctor(DryIoc.IScope,System.Object)">
            <summary>Creates scope with optional parent and name.</summary>
        </member>
        <member name="M:DryIoc.Scope.Clone">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Scope.Clone(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Scope.GetOrAdd(System.Int32,DryIoc.CreateScopedValue,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Scope.GetOrAddViaFactoryDelegate(System.Int32,DryIoc.FactoryDelegate,DryIoc.IResolverContext,System.Int32)">
            <inheritdoc />
        </member>
        <member name="F:DryIoc.Scope.WaitForScopedServiceIsCreatedTimeoutTicks">
            <summary>The amount of time to wait for the other party to create the scoped (or singleton) service. 
            The default value of 5000 ticks rougly corresponds to the 5 seconds.</summary>
        </member>
        <member name="M:DryIoc.Scope.TryGetOrAddWithoutClosure(System.Int32,DryIoc.IResolverContext,System.Linq.Expressions.Expression,System.Boolean,System.Func{DryIoc.IResolverContext,System.Linq.Expressions.Expression,System.Boolean,System.Object},System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Scope.SetOrAdd(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Scope.GetOrTryAdd(System.Int32,System.Object,System.Int32)">
            [Obsolete("Removing because it is not used")]
        </member>
        <member name="M:DryIoc.Scope.TryGet(System.Object@,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Scope.TrackDisposable(System.Object,System.Int32)">
            <summary>Can be used to manually add service for disposal</summary>
        </member>
        <member name="M:DryIoc.Scope.TrackDisposableWithoutDisposalOrder``1(``0)">
            <summary>Tracked item will be disposed with the scope.</summary> 
        </member>
        <member name="M:DryIoc.Scope.SetUsedInstance(System.Type,DryIoc.FactoryDelegate)">
            [Obsolete("Removing because it is not used")]
        </member>
        <member name="M:DryIoc.Scope.SetUsedInstance(System.Int32,System.Type,DryIoc.FactoryDelegate)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Scope.TryGetUsedInstance(DryIoc.IResolverContext,System.Type,System.Object@)">
            <summary>Try retrieve instance from the small registry.</summary>
        </member>
        <member name="M:DryIoc.Scope.GetEnumerator">
            <summary>Enumerates all the parent scopes upwards starting from this one.</summary>
        </member>
        <member name="M:DryIoc.Scope.Dispose">
            <summary>Disposes all stored <see cref="T:System.IDisposable"/> objects and empties item storage.
            The disposal happens in REVERSE resolution / injection order, consumer first, dependency next.
            It will allow consumer to do something with its dependency before it is disposed.</summary>
            <remarks>All disposal exceptions are swallowed except the ContainerException,
            which may indicate container misconfiguration.</remarks>
        </member>
        <member name="M:DryIoc.Scope.ToString">
            <summary>Prints scope info (name and parent) to string for debug purposes.</summary>
        </member>
        <member name="T:DryIoc.SetCurrentScopeHandler">
            <summary>Delegate to get new scope from old/existing current scope.</summary>
            <param name="oldScope">Old/existing scope to change.</param>
            <returns>New scope or old if do not want to change current scope.</returns>
        </member>
        <member name="T:DryIoc.IScopeContext">
            <summary>Provides ambient current scope and optionally scope storage for container,
            examples are HttpContext storage, Execution context, Thread local.</summary>
        </member>
        <member name="M:DryIoc.IScopeContext.GetCurrentOrDefault">
            <summary>Returns current scope or null if no ambient scope available at the moment.</summary>
            <returns>Current scope or null.</returns>
        </member>
        <member name="M:DryIoc.IScopeContext.SetCurrent(DryIoc.SetCurrentScopeHandler)">
            <summary>Changes current scope using provided delegate. Delegate receives current scope as input and
            should return new current scope.</summary>
            <param name="setCurrentScope">Delegate to change the scope.</param>
            <remarks>Important: <paramref name="setCurrentScope"/> may be called multiple times in concurrent environment.
            Make it predictable by removing any side effects.</remarks>
            <returns>New current scope. So it is convenient to use method in "using (var newScope = ctx.SetCurrent(...))".</returns>
        </member>
        <member name="T:DryIoc.ThreadScopeContext">
            <summary>Tracks one current scope per thread, so the current scope in different tread would be different or null,
            if not yet tracked. Context actually stores scope references internally, so it should be disposed to free them.</summary>
        </member>
        <member name="F:DryIoc.ThreadScopeContext.ScopeContextName">
            <summary>Provides static name for context. It is OK because its constant.</summary>
        </member>
        <member name="M:DryIoc.ThreadScopeContext.GetCurrentOrDefault">
            <summary>Returns current scope in calling Thread or null, if no scope tracked.</summary>
        </member>
        <member name="M:DryIoc.ThreadScopeContext.SetCurrent(DryIoc.SetCurrentScopeHandler)">
            <summary>Change current scope for the calling Thread.</summary>
        </member>
        <member name="M:DryIoc.ThreadScopeContext.Dispose">
            <summary>Disposes the scopes and empties internal scope storage.</summary>
        </member>
        <member name="F:DryIoc.ThreadScopeContext._scopes">
            Collection of scoped by their managed thread id
        </member>
        <member name="T:DryIoc.IReuse">
            <summary>Simplified scope agnostic reuse abstraction. More easy to implement,
             and more powerful as can be based on other storage beside reuse.</summary>
        </member>
        <member name="P:DryIoc.IReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="P:DryIoc.IReuse.Name">
            <summary>Optional name. Use to find matching scope by the name.
            It also may be interpreted as object[] Names for matching with multiple scopes </summary>
        </member>
        <member name="M:DryIoc.IReuse.CanApply(DryIoc.Request)">
            <summary>Returns true if reuse can be applied: may check if scope or other reused item storage is present.</summary>
        </member>
        <member name="M:DryIoc.IReuse.Apply(DryIoc.Request,System.Linq.Expressions.Expression)">
            <summary>Returns composed expression.</summary>
        </member>
        <member name="T:DryIoc.SingletonReuse">
            <summary>Returns container bound scope for storing singleton objects.</summary>
        </member>
        <member name="F:DryIoc.SingletonReuse.DefaultLifespan">
            <summary>Big lifespan.</summary>
        </member>
        <member name="P:DryIoc.SingletonReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="P:DryIoc.SingletonReuse.Name">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.SingletonReuse.CanApply(DryIoc.Request)">
            <summary>Returns true because singleton is always available.</summary>
        </member>
        <member name="M:DryIoc.SingletonReuse.Apply(DryIoc.Request,System.Linq.Expressions.Expression)">
            <summary>Returns expression call to GetOrAddItem.</summary>
        </member>
        <member name="M:DryIoc.SingletonReuse.ToExpression(System.Func{System.Object,System.Linq.Expressions.Expression})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.SingletonReuse.ToString">
            <summary>Pretty prints reuse name and lifespan</summary>
        </member>
        <member name="T:DryIoc.CurrentScopeReuse">
            <summary>Specifies that instances are created, stored and disposed together with some scope.</summary>
        </member>
        <member name="F:DryIoc.CurrentScopeReuse.DefaultLifespan">
            <summary>Less than Singleton's</summary>
        </member>
        <member name="P:DryIoc.CurrentScopeReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="P:DryIoc.CurrentScopeReuse.Name">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.CanApply(DryIoc.Request)">
            <summary>Returns true if scope is open and the name is matching with reuse <see cref="P:DryIoc.CurrentScopeReuse.Name"/>.</summary>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.Apply(DryIoc.Request,System.Linq.Expressions.Expression)">
            <summary>Creates scoped item creation and access expression.</summary>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.ToExpression(System.Func{System.Object,System.Linq.Expressions.Expression})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.ToString">
            <summary>Pretty prints reuse to string.</summary> <returns>Reuse string.</returns>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.#ctor(System.Object,System.Boolean,System.Int32)">
            <summary>Creates the reuse.</summary>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.#ctor(System.Object,System.Boolean)">
            <summary>Creates the reuse optionally specifying its name.</summary>
        </member>
        <member name="F:DryIoc.CurrentScopeReuse.ScopedOrSingleton">
            <summary>Flag indicating that it is a scope or singleton.</summary>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetScopedOrSingletonViaFactoryDelegate(DryIoc.IResolverContext,System.Int32,DryIoc.FactoryDelegate,System.Int32)">
            Subject
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.TrackScopedOrSingleton(DryIoc.IResolverContext,System.Object)">
            <summary>Tracks the Unordered disposal in the current scope or in the singleton as fallback</summary>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetScopedViaFactoryDelegateNoDisposalIndex(DryIoc.IResolverContext,System.Boolean,System.Int32,DryIoc.FactoryDelegate)">
            Subject
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetScopedViaFactoryDelegate(DryIoc.IResolverContext,System.Boolean,System.Int32,DryIoc.FactoryDelegate,System.Int32)">
            Subject
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetNameScopedViaFactoryDelegate(DryIoc.IResolverContext,System.Object,System.Boolean,System.Int32,DryIoc.FactoryDelegate,System.Int32)">
            Subject
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.TrackScoped(DryIoc.IResolverContext,System.Boolean,System.Object)">
            Subject
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.TrackNameScoped(DryIoc.IResolverContext,System.Object,System.Boolean,System.Object)">
            Subject
        </member>
        <member name="T:DryIoc.IScopeName">
            <summary>Abstracts way to match reuse and scope names</summary>
        </member>
        <member name="M:DryIoc.IScopeName.Match(System.Object)">
            <summary>Does the job.</summary>
        </member>
        <member name="T:DryIoc.CompositeScopeName">
            <summary>Represents multiple names</summary>
        </member>
        <member name="M:DryIoc.CompositeScopeName.Of(System.Object[])">
            <summary>Wraps multiple names</summary>
        </member>
        <member name="M:DryIoc.CompositeScopeName.Match(System.Object)">
            <summary>Matches all the name in a loop until first match is found, otherwise returns false.</summary>
        </member>
        <member name="T:DryIoc.ResolutionScopeName">
            <summary>Holds the name for the resolution scope.</summary>
        </member>
        <member name="M:DryIoc.ResolutionScopeName.Of(System.Type,System.Object)">
            <summary>Creates scope with specified service type and key</summary>
        </member>
        <member name="M:DryIoc.ResolutionScopeName.Of``1(System.Object)">
            <summary>Creates scope with specified service type and key.</summary>
        </member>
        <member name="F:DryIoc.ResolutionScopeName.ServiceType">
            <summary>Type of service opening the scope.</summary>
        </member>
        <member name="F:DryIoc.ResolutionScopeName.ServiceKey">
            <summary>Optional service key of service opening the scope.</summary>
        </member>
        <member name="M:DryIoc.ResolutionScopeName.Match(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ResolutionScopeName.ToString">
            <summary>String representation for easy debugging and understood error messages.</summary>
        </member>
        <member name="T:DryIoc.Reuse">
            <summary>Specifies pre-defined reuse behaviors supported by container:
            used when registering services into container with <see cref="T:DryIoc.Registrator"/> methods.</summary>
        </member>
        <member name="F:DryIoc.Reuse.Transient">
            <summary>Synonym for absence of reuse.</summary>
        </member>
        <member name="F:DryIoc.Reuse.Singleton">
            <summary>Specifies to store single service instance per <see cref="T:DryIoc.Container"/>.</summary>
        </member>
        <member name="F:DryIoc.Reuse.Scoped">
            <summary>Same as InCurrentScope. From now on will be the default name.</summary>
        </member>
        <member name="M:DryIoc.Reuse.ScopedTo(System.Object)">
            <summary>Same as InCurrentNamedScope. From now on will be the default name.</summary>
        </member>
        <member name="M:DryIoc.Reuse.ScopedTo(System.Object,System.Boolean,System.Int32)">
            <summary>Specifies all the scope details</summary>
        </member>
        <member name="M:DryIoc.Reuse.ScopedTo(System.Object[])">
            <summary>Scoped to multiple names.</summary>
        </member>
        <member name="M:DryIoc.Reuse.ScopedTo(System.Type,System.Object)">
            <summary>[Obsolete("Use ScopedToService to prevent ambiguity with the ScopeTo(object name) where name is the Type")]</summary>
        </member>
        <member name="M:DryIoc.Reuse.ScopedToService(System.Type,System.Object)">
            <summary>Scoped to the scope created by the service with the specified type and optional key</summary>
        </member>
        <member name="M:DryIoc.Reuse.ScopedTo``1(System.Object)">
            <summary>Scoped to the scope created by the service with the specified type and optional key</summary>
        </member>
        <member name="M:DryIoc.Reuse.ScopedToService``1(System.Object)">
            <summary>Scoped to the scope created by the service with the specified type and optional key</summary>
        </member>
        <member name="F:DryIoc.Reuse.ScopedOrSingleton">
            <summary>The same as <see cref="F:DryIoc.Reuse.InCurrentScope"/> but if no open scope available will fallback to <see cref="F:DryIoc.Reuse.Singleton"/></summary>
            <remarks>The <see cref="F:DryIoc.Error.DependencyHasShorterReuseLifespan"/> is applied the same way as for <see cref="F:DryIoc.Reuse.InCurrentScope"/> reuse.</remarks>
        </member>
        <member name="F:DryIoc.Reuse.InResolutionScope">
            <summary>Obsolete: same as <see cref="F:DryIoc.Reuse.Scoped"/>.</summary>
        </member>
        <member name="F:DryIoc.Reuse.InCurrentScope">
            <summary>Obsolete: same as <see cref="F:DryIoc.Reuse.Scoped"/>.</summary>
        </member>
        <member name="M:DryIoc.Reuse.InCurrentNamedScope(System.Object)">
            <summary>Returns current scope reuse with specific name to match with scope.
            If name is not specified then function returns <see cref="F:DryIoc.Reuse.InCurrentScope"/>.</summary>
            <param name="name">(optional) Name to match with scope.</param>
            <returns>Created current scope reuse.</returns>
        </member>
        <member name="M:DryIoc.Reuse.InResolutionScopeOf(System.Type,System.Object)">
            <summary>Obsolete: will be soon - please use ScopedToService instead.</summary>
        </member>
        <member name="M:DryIoc.Reuse.InResolutionScopeOf``1(System.Object)">
            <summary>Obsolete: will be soon - please use ScopedToService instead.</summary>
        </member>
        <member name="F:DryIoc.Reuse.InThread">
            <summary>Same as Scoped but requires <see cref="T:DryIoc.ThreadScopeContext"/>.</summary>
        </member>
        <member name="F:DryIoc.Reuse.WebRequestScopeName">
            <summary>Special name that by convention recognized by <see cref="F:DryIoc.Reuse.InWebRequest"/>.</summary>
        </member>
        <member name="F:DryIoc.Reuse.InWebRequest">
            <summary>Obsolete: please prefer using <see cref="F:DryIoc.Reuse.Scoped"/> instead.
            The named scope has performance drawback comparing to just a scope.
            If you need to distinguish nested scope, give names to them instead of naming the top web request scope.</summary>
        </member>
        <member name="T:DryIoc.IfUnresolved">
            <summary>Policy to handle unresolved service.</summary>
        </member>
        <member name="F:DryIoc.IfUnresolved.Throw">
            <summary>If service is unresolved for whatever means, it will throw the respective exception.</summary>
        </member>
        <member name="F:DryIoc.IfUnresolved.ReturnDefault">
            <summary>If service is unresolved for whatever means, it will return default(serviceType) value.</summary>
        </member>
        <member name="F:DryIoc.IfUnresolved.ReturnDefaultIfNotRegistered">
            <summary>If service is not registered, then it will return default, for other errors it will throw.</summary>
        </member>
        <member name="T:DryIoc.IResolver">
            <summary>Declares minimal API for service resolution. 
            Resolve default and keyed is separated because of optimization for faster resolution of the former.</summary>
        </member>
        <member name="M:DryIoc.IResolver.Resolve(System.Type,DryIoc.IfUnresolved)">
            <summary>Resolves default (non-keyed) service from container and returns created service object.</summary>
            <param name="serviceType">Service type to search and to return.</param>
            <param name="ifUnresolved">Says what to do if service is unresolved.</param>
            <returns>Created service object or default based on <paramref name="ifUnresolved"/> provided.</returns>
        </member>
        <member name="M:DryIoc.IResolver.Resolve(System.Type,System.Object,DryIoc.IfUnresolved,System.Type,DryIoc.Request,System.Object[])">
            <summary>Resolves service instance from container.</summary>
            <param name="serviceType">Service type to search and to return.</param>
            <param name="serviceKey">(optional) service key used for registering service.</param>
            <param name="ifUnresolved">(optional) Says what to do if service is unresolved.</param>
            <param name="requiredServiceType">(optional) Registered or wrapped service type to use instead of <paramref name="serviceType"/>,
                or wrapped type for generic wrappers.  The type should be assignable to return <paramref name="serviceType"/>.</param>
            <param name="preResolveParent">(optional) Dependency chain info.</param>
            <param name="args">(optional) To specify the dependency objects to use instead of resolving them from container.</param>
            <returns>Created service object or default based on <paramref name="ifUnresolved"/> parameter.</returns>
        </member>
        <member name="M:DryIoc.IResolver.ResolveMany(System.Type,System.Object,System.Type,DryIoc.Request,System.Object[])">
            <summary>Resolves all services registered for specified <paramref name="serviceType"/>, or if not found returns
            empty enumerable. If <paramref name="serviceType"/> specified then returns only (single) service registered with this type.</summary>
            <param name="serviceType">Return type of an service item.</param>
            <param name="serviceKey">(optional) Resolve only single service registered with the key.</param>
            <param name="requiredServiceType">(optional) Actual registered service to search for.</param>
            <param name="preResolveParent">Dependency resolution path info.</param>
            <param name="args">(optional) To specify the dependency objects to use instead of resolving them from container.</param>
            <returns>Enumerable of found services or empty. Does Not throw if no service found.</returns>
        </member>
        <member name="T:DryIoc.IfAlreadyRegistered">
            <summary>Specifies options to handle situation when registered service is already present in the registry.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed">
            <summary>Appends new default registration or throws registration with the same key.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.Throw">
            <summary>Throws if default or registration with the same key is already exist.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.Keep">
            <summary>Keeps old default or keyed registration ignoring new registration: ensures Register-Once semantics.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.Replace">
            <summary>Replaces old registration with new one.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.AppendNewImplementation">
            <summary>Adds the new implementation or null (Made.Of),
            otherwise keeps the previous registration of the same implementation type.</summary>
        </member>
        <member name="T:DryIoc.ServiceRegistrationInfo">
            <summary>Existing registration info.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.Factory">
            <summary>Registered factory.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.ServiceType">
            <summary>Required service type.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.OptionalServiceKey">
            <summary>May be <c>null</c> for single default service, or <see cref="T:DryIoc.DefaultKey"/> for multiple default services.</summary>
        </member>
        <member name="P:DryIoc.ServiceRegistrationInfo.FactoryRegistrationOrder">
            <summary>Provides registration order across all factory registrations in container.</summary>
            <remarks>May be the same for factory registered with multiple services
            OR for closed-generic factories produced from the single open-generic registration.</remarks>
        </member>
        <member name="P:DryIoc.ServiceRegistrationInfo.ImplementationType">
            <summary>Implementation type if available.</summary>
        </member>
        <member name="P:DryIoc.ServiceRegistrationInfo.AsResolutionRoot">
            <summary>Shortcut to <see cref="P:DryIoc.Setup.AsResolutionRoot"/> property, useful to find all roots</summary>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.ToServiceInfo">
            <summary>Shortcut to service info.</summary>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.ToServiceInfo(System.Type)">
            <summary>Overrides the service type and pushes the original service type to required service type</summary>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.ToServiceInfo``1">
            <summary>Overrides the service type and pushes the original service type to required service type</summary>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.#ctor(DryIoc.Factory,System.Type,System.Object)">
            <summary>Creates info. Registration order is figured out automatically based on Factory.</summary>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.CompareTo(DryIoc.ServiceRegistrationInfo)">
            <summary>Orders by registration</summary>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.ToString">
            <summary>Pretty-prints info to string.</summary>
        </member>
        <member name="T:DryIoc.IRegistrator">
            <summary>Defines operations that for changing registry, and checking if something exist in registry.</summary>
        </member>
        <member name="M:DryIoc.IRegistrator.Register(DryIoc.Factory,System.Type,System.Object,System.Nullable{DryIoc.IfAlreadyRegistered},System.Boolean)">
            <summary>Registers factory in registry with specified service type and key for lookup.
            Returns true if factory was added to registry, false otherwise. False may be in case of <see cref="F:DryIoc.IfAlreadyRegistered.Keep"/>
            setting and already existing factory</summary>
            <param name="factory">To register.</param>
            <param name="serviceType">Service type as unique key in registry for lookup.</param>
            <param name="serviceKey">Service key as complementary lookup for the same service type.</param>
            <param name="ifAlreadyRegistered">Policy how to deal with already registered factory with same service type and key.</param>
            <param name="isStaticallyChecked">[performance] Confirms that service and implementation types are statically checked by compiler.</param>
            <returns>True if factory was added to registry, false otherwise.
            False may be in case of <see cref="F:DryIoc.IfAlreadyRegistered.Keep"/> setting and already existing factory.</returns>
        </member>
        <member name="M:DryIoc.IRegistrator.IsRegistered(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if expected factory is registered with specified service key and type.
            Not provided or <c>null</c> <paramref name="serviceKey"/> means to check the <paramref name="serviceType"/> 
            alone with any service key.</summary>
        </member>
        <member name="M:DryIoc.IRegistrator.Unregister(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes factory with specified service type and key from registry and cache.
            BUT consuming services may still hold on the resolved service instance.
            The cache of consuming services may also hold on the unregistered service. Use `IContainer.ClearCache` to clear all cache.</summary>
        </member>
        <member name="M:DryIoc.IRegistrator.GetServiceRegistrations">
            <summary>Returns all registered service factories with their Type and optional Key.
            Decorator and Wrapper types are not included.</summary>
        </member>
        <member name="M:DryIoc.IRegistrator.GetRegisteredFactories(System.Type,System.Object,DryIoc.FactoryType)">
            <summary>Searches for registered factories by type, and key (if specified),
            and by factory type (by default uses <see cref="F:DryIoc.FactoryType.Service"/>).
            May return empty, 1 or multiple factories.</summary>
        </member>
        <member name="M:DryIoc.IRegistrator.UseInstance(System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            Puts instance into the current scope or singletons.
        </member>
        <member name="M:DryIoc.IRegistrator.Use(System.Type,DryIoc.FactoryDelegate)">
            <summary>Puts instance created via the passed factory on demand into the current or singleton scope</summary>
        </member>
        <member name="T:DryIoc.RegistrySharing">
            <summary>What to do with registrations when creating the new container from the existent one.</summary>
        </member>
        <member name="F:DryIoc.RegistrySharing.Share">
            <summary>Shares both registrations and resolution cache if any</summary>
        </member>
        <member name="F:DryIoc.RegistrySharing.CloneButKeepCache">
            <summary>Clones the registrations but preserves the resolution cache</summary>
        </member>
        <member name="F:DryIoc.RegistrySharing.CloneAndDropCache">
            <summary>Clones the registrations and drops the cache -- full reset!</summary>
        </member>
        <member name="T:DryIoc.IContainer">
            <summary>Combines registrator and resolver roles, plus rules and scope management.</summary>
        </member>
        <member name="P:DryIoc.IContainer.Rules">
            <summary>Rules for defining resolution/registration behavior throughout container.</summary>
        </member>
        <member name="P:DryIoc.IContainer.OwnCurrentScope">
            <summary>Represents scope bound to container itself, and not an ambient (context) thingy.</summary>
        </member>
        <member name="M:DryIoc.IContainer.With(DryIoc.Rules,DryIoc.IScopeContext,DryIoc.RegistrySharing,DryIoc.IScope)">
            <summary>Creates new container from the current one by specifying the listed parameters.
            If the null or default values are provided then the default or new values will be applied.
            Nothing will be inherited from the current container.
            If you want to inherit something you need to provide it as parameter.</summary>
        </member>
        <member name="M:DryIoc.IContainer.With(DryIoc.IResolverContext,DryIoc.Rules,DryIoc.IScopeContext,DryIoc.RegistrySharing,DryIoc.IScope,DryIoc.IScope)">
            <summary>Creates new container from the current one by specifying the listed parameters.
            If the null or default values are provided then the default or new values will be applied.
            Nothing will be inherited from the current container. If you want to inherit something you need to provide it as parameter.</summary>
        </member>
        <member name="M:DryIoc.IContainer.With(DryIoc.IResolverContext,DryIoc.Rules,DryIoc.IScopeContext,DryIoc.RegistrySharing,DryIoc.IScope,DryIoc.IScope,System.Nullable{DryIoc.IsRegistryChangePermitted})">
            <summary>Creates new container from the current one by specifying the listed parameters.
            If the null or default values are provided then the default or new values will be applied.
            Nothing will be inherited from the current container. If you want to inherit something you need to provide it as parameter.</summary>
        </member>
        <member name="M:DryIoc.IContainer.WithNoMoreRegistrationAllowed(System.Boolean)">
            <summary>Produces new container which prevents any further registrations.</summary>
            <param name="ignoreInsteadOfThrow">(optional)Controls what to do with registrations: ignore or throw exception.
            Throws exception by default.</param>
            <returns>New container preserving all current container state but disallowing registrations.</returns>
        </member>
        <member name="M:DryIoc.IContainer.ResolveFactory(DryIoc.Request)">
            <summary>Searches for requested factory in registry, and then using <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/>.</summary>
            <param name="request">Factory request.</param>
            <returns>Found factory, otherwise null if <see cref="P:DryIoc.Request.IfUnresolved"/> is set to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetServiceFactoryOrDefault(DryIoc.Request)">
            <summary>Searches for registered service factory and returns it, or null if not found.
            Will use <see cref="P:DryIoc.Rules.FactorySelector"/> if specified.</summary>
            <param name="request">Factory request.</param>
            <returns>Found factory or null.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetAllServiceFactories(System.Type,System.Boolean)">
            <summary>Finds all registered default and keyed service factories and returns them.
            It skips decorators and wrappers.</summary>
            <param name="serviceType">Service type to look for, may be open-generic type too.</param>
            <param name="bothClosedAndOpenGenerics">(optional) For generic serviceType instructs to look for
            both closed and open-generic registrations.</param>
            <returns>Enumerable of found pairs.</returns>
            <remarks>Returned Key item should not be null - it should be <see cref="F:DryIoc.DefaultKey.Value"/>.</remarks>
        </member>
        <member name="M:DryIoc.IContainer.GetWrapperFactoryOrDefault(System.Type)">
            <summary>Searches for registered wrapper factory and returns it, or null if not found.</summary>
            <param name="serviceType">Service type to look for.</param> <returns>Found wrapper factory or null.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetDecoratorFactoriesOrDefault(System.Type)">
            <summary>Returns all decorators registered for the service type.</summary> <returns>Decorator factories.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetDecoratorExpressionOrDefault(DryIoc.Request)">
            <summary>Creates decorator expression: it could be either Func{TService,TService},
            or service expression for replacing decorators.</summary>
            <param name="request">Decorated service request.</param>
            <returns>Decorator expression.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetWrappedType(System.Type,System.Type)">
            <summary>If <paramref name="serviceType"/> is generic type then this method checks if the type registered as generic wrapper,
            and recursively unwraps and returns its type argument. This type argument is the actual service type we want to find.
            Otherwise, method returns the input <paramref name="serviceType"/>.</summary>
            <param name="serviceType">Type to unwrap. Method will return early if type is not generic.</param>
            <param name="requiredServiceType">Required service type or null if don't care.</param>
            <returns>Unwrapped service type in case it corresponds to registered generic wrapper, or input type in all other cases.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetConstantExpression(System.Object,System.Type,System.Boolean)">
            <summary>Converts known items into custom expression or wraps in a constant expression.</summary>
            <param name="item">Item to convert.</param>
            <param name="itemType">(optional) Type of item, otherwise item <see cref="M:System.Object.GetType"/>.</param>
            <param name="throwIfStateRequired">(optional) Throws for non-primitive and not-recognized items,
            identifying that result expression require run-time state. For compiled expression it means closure in lambda delegate.</param>
            <returns>Returns constant or state access expression for added items.</returns>
        </member>
        <member name="M:DryIoc.IContainer.ClearCache(System.Type,System.Nullable{DryIoc.FactoryType},System.Object)">
            <summary>Clears cache for specified service(s). But does not clear instances of already resolved/created singletons and scoped services!</summary>
            <param name="serviceType">Target service type.</param>
            <param name="factoryType">(optional) If not specified, clears cache for all <see cref="T:DryIoc.FactoryType"/>.</param>
            <param name="serviceKey">(optional) If omitted, the cache will be cleared for all registrations of <paramref name="serviceType"/>.</param>
            <returns>True if target service was found, false - otherwise.</returns>
        </member>
        <member name="M:DryIoc.IContainer.Use(System.Type,DryIoc.FactoryDelegate)">
            Puts instance created via the passed factory on demand into the current or singleton scope
        </member>
        <member name="M:DryIoc.IContainer.UseInstance(System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            [Obsolete("Replaced by `Use` to put runtime data into container scopes and with `RegisterInstance` as a sugar for `RegisterDelegate(_ => instance)`")]
        </member>
        <member name="T:DryIoc.LazyEnumerable`1">
            <summary>Resolves all registered services of <typeparamref name="TService"/> type on demand,
            when enumerator <see cref="M:System.Collections.IEnumerator.MoveNext"/> called. If service type is not found, empty returned.</summary>
            <typeparam name="TService">Service type to resolve.</typeparam>
        </member>
        <member name="F:DryIoc.LazyEnumerable`1.Items">
            <summary>Exposes internal items enumerable.</summary>
        </member>
        <member name="M:DryIoc.LazyEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Wraps lazy resolved items.</summary> <param name="items">Lazy resolved items.</param>
        </member>
        <member name="M:DryIoc.LazyEnumerable`1.GetEnumerator">
            <summary>Return items enumerator.</summary> 
        </member>
        <member name="T:DryIoc.Meta`2">
            <summary>Wrapper type to box service with associated arbitrary metadata object.</summary>
            <typeparam name="T">Service type.</typeparam>
            <typeparam name="TMetadata">Arbitrary metadata object type.</typeparam>
        </member>
        <member name="F:DryIoc.Meta`2.Value">
            <summary>Value or object with associated metadata.</summary>
        </member>
        <member name="F:DryIoc.Meta`2.Metadata">
            <summary>Associated metadata object. Could be anything.</summary>
        </member>
        <member name="M:DryIoc.Meta`2.#ctor(`0,`1)">
            <summary>Boxes value and its associated metadata together.</summary>
        </member>
        <member name="T:DryIoc.ContainerException">
            Exception that container throws in case of error. Dedicated exception type simplifies
            filtering or catching container relevant exceptions from client code.
        </member>
        <member name="F:DryIoc.ContainerException.Error">
            <summary>Error code of exception, possible values are listed in <see cref="F:DryIoc.ContainerException.Error"/> class.</summary>
        </member>
        <member name="P:DryIoc.ContainerException.ErrorName">
            <summary>Simplifies the access to the error name.</summary>
        </member>
        <member name="F:DryIoc.ContainerException.CollectedExceptions">
            <summary>Many collected exceptions</summary>
        </member>
        <member name="M:DryIoc.ContainerException.Of(DryIoc.ErrorCheck,System.Int32,System.Object,System.Object,System.Object,System.Object,System.Exception)">
            <summary>Creates exception by wrapping <paramref name="errorCode"/> and its message,
            optionally with <paramref name="innerException"/> exception.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.GetMessage(DryIoc.ErrorCheck,System.Int32)">
            <summary>Gets error message based on provided args.</summary> <param name="errorCheck"></param> <param name="errorCode"></param>
        </member>
        <member name="M:DryIoc.ContainerException.Print(System.Object)">
            <summary>Prints argument for formatted message.</summary> <param name="arg">To print.</param> <returns>Printed string.</returns>
        </member>
        <member name="M:DryIoc.ContainerException.#ctor(System.Int32,DryIoc.ContainerException[])">
            <summary>Collects many exceptions.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.#ctor(System.Int32,System.String)">
            <summary>Creates exception with message describing cause and context of error.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.#ctor(System.Int32,System.String,System.Exception)">
            <summary>Creates exception with message describing cause and context of error,
            and leading/system exception causing it.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.FormatMessage(System.String,System.String)">
            <summary>The default exception message format.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.#ctor(System.Int32,System.String,System.Exception,System.Func{System.Int32,System.String,System.Exception,System.String})">
            <summary>Allows the formatting of the final exception message.</summary>
        </member>
        <member name="T:DryIoc.Error">
            <summary>Defines error codes and error messages for all DryIoc exceptions (DryIoc extensions may define their own.)</summary>
        </member>
        <member name="F:DryIoc.Error.Messages">
            <summary>List of error messages indexed with code.</summary>
        </member>
        <member name="M:DryIoc.Error.NameOf(System.Int32)">
            <summary>Returns the name of error with the provided error code.</summary>
        </member>
        <member name="T:DryIoc.ErrorCheck">
            <summary>Checked error condition, possible error sources.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.Unspecified">
            <summary>Unspecified, just throw.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.InvalidCondition">
            <summary>Predicate evaluated to false.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.IsNull">
            <summary>Checked object is null.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.IsNotOfType">
            <summary>Checked object is of unexpected type.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.TypeIsNotOfType">
            <summary>Checked type is not assignable to expected type</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.OperationThrows">
            <summary>Invoked operation throws, it is source of inner exception.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.CollectedExceptions">
            <summary>Just stores many collected exceptions.</summary>
        </member>
        <member name="T:DryIoc.Throw">
            <summary>Enables more clean error message formatting and a bit of code contracts.</summary>
        </member>
        <member name="M:DryIoc.Throw.GetDefaultMessage(DryIoc.ErrorCheck)">
            <summary>Returns the default message specified for <see cref="T:DryIoc.ErrorCheck"/> code.</summary>
        </member>
        <member name="T:DryIoc.Throw.GetMatchedExceptionHandler">
            <summary>Declares mapping between <see cref="T:DryIoc.ErrorCheck"/> type and <paramref name="error"/> code to specific <see cref="T:System.Exception"/>.</summary>
        </member>
        <member name="F:DryIoc.Throw.GetMatchedException">
            <summary>Returns matched exception for error check and error code.</summary>
        </member>
        <member name="M:DryIoc.Throw.If(System.Boolean,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws matched exception with provided error code if throw condition is true.</summary>
        </member>
        <member name="M:DryIoc.Throw.ThrowIf``1(``0,System.Boolean,System.Int32,System.Object,System.Object,System.Object)">
            <summary>Throws matched exception with provided error code if throw condition is true.
            Otherwise returns source <paramref name="arg0"/>.</summary>
        </member>
        <member name="M:DryIoc.Throw.ThrowIfNull``1(``0,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws exception if <paramref name="arg"/> is null, otherwise returns <paramref name="arg"/>.</summary>
        </member>
        <member name="M:DryIoc.Throw.ThrowIfNotInstanceOf``1(``0,System.Type,System.Int32,System.Object,System.Object)">
            <summary>Throws exception if <paramref name="arg0"/> is not assignable to type specified by <paramref name="arg1"/>,
            otherwise just returns <paramref name="arg0"/>.</summary>
        </member>
        <member name="M:DryIoc.Throw.ThrowIfNotImplementedBy(System.Type,System.Type,System.Int32,System.Object,System.Object)">
            <summary>Throws if <paramref name="arg0"/> is not assignable from <paramref name="arg1"/>.</summary>
        </member>
        <member name="M:DryIoc.Throw.IfThrows``2(System.Func{``1},System.Boolean,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Invokes <paramref name="operation"/> and in case of <typeparamref name="TEx"/> re-throws it as inner-exception.</summary>
        </member>
        <member name="M:DryIoc.Throw.It(System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Just throws the exception with the <paramref name="error"/> code.</summary>
        </member>
        <member name="M:DryIoc.Throw.For``1(System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws <paramref name="error"/> instead of returning value of <typeparamref name="T"/>.
            Supposed to be used in expression that require some return value.</summary>
        </member>
        <member name="M:DryIoc.Throw.For``1(System.Boolean,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws if contidion is true, otherwise returns the `default(T)` value</summary>
        </member>
        <member name="M:DryIoc.Throw.Many(System.Int32,DryIoc.ContainerException[])">
            <summary>Throws the one with manyh collected exceptions</summary>
        </member>
        <member name="T:DryIoc.ThrowInGeneratedCode">
            <summary>Called from the generated code to check if WeakReference.Value is GCed.</summary>
        </member>
        <member name="M:DryIoc.ThrowInGeneratedCode.WeakRefReuseWrapperGCed(System.Object)">
            <summary>Throws if the object is null.</summary>
        </member>
        <member name="T:DryIoc.ReflectionTools">
            <summary>Contains helper methods to work with Type: for instance to find Type implemented base types and interfaces, etc.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.TryRethrowWithPreservedStackTrace(System.Exception)">
            <summary>Preserves the stack trace before re-throwing.</summary>
        </member>
        <member name="T:DryIoc.ReflectionTools.AsImplementedType">
            <summary>Flags for <see cref="M:DryIoc.ReflectionTools.GetImplementedTypes(System.Type,DryIoc.ReflectionTools.AsImplementedType)"/> method.</summary>
        </member>
        <member name="F:DryIoc.ReflectionTools.AsImplementedType.None">
            <summary>Include nor object not source type.</summary>
        </member>
        <member name="F:DryIoc.ReflectionTools.AsImplementedType.SourceType">
            <summary>Include source type to list of implemented types.</summary>
        </member>
        <member name="F:DryIoc.ReflectionTools.AsImplementedType.ObjectType">
            <summary>Include <see cref="T:System.Object"/> type to list of implemented types.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetImplementedTypes(System.Type,DryIoc.ReflectionTools.AsImplementedType)">
            <summary>Returns all interfaces and all base types (in that order) implemented by <paramref name="sourceType"/>.
            Specify <paramref name="asImplementedType"/> to include <paramref name="sourceType"/> itself as first item and
            <see cref="T:System.Object"/> type as the last item.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetImplementedInterfaces(System.Type)">
            <summary>Gets a collection of the interfaces implemented by the current type and its base types.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAllMembers(System.Type,System.Boolean)">
            <summary>Gets all declared and if specified, the base members too.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.ContainsAllGenericTypeParameters(System.Type,System.Type[])">
            <summary>Returns true if the <paramref name="openGenericType"/> contains all generic parameters
            from <paramref name="genericParameters"/>.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsCompilerGenerated(System.Type)">
            <summary>Returns true if class is compiler generated. Checking for CompilerGeneratedAttribute
            is not enough, because this attribute is not applied for classes generated from "async/await".</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsGeneric(System.Type)">
            <summary>Returns true if type is generic.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsGenericDefinition(System.Type)">
            <summary>Returns true if type is generic type definition (open type).</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsClosedGeneric(System.Type)">
            <summary>Returns true if type is closed generic: does not have open generic parameters, only closed/concrete ones.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsOpenGeneric(System.Type)">
            <summary>Returns true if type if open generic: contains at list one open generic parameter. Could be
            generic type definition as well.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetGenericDefinitionOrNull(System.Type)">
            <summary>Returns generic type definition if type is generic and null otherwise.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetGenericParamsAndArgs(System.Type)">
            <summary>Returns generic type parameters and arguments in order they specified. If type is not generic, returns empty array.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetGenericParamConstraints(System.Type)">
            <summary>Returns array of interface and base class constraints for provider generic parameter type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetArrayElementTypeOrNull(System.Type)">
            <summary>If type is array returns is element type, otherwise returns null.</summary>
            <param name="type">Source type.</param> <returns>Array element type or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetBaseType(System.Type)">
            <summary>Return base type or null, if not exist (the case for only for object type).</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsPublicOrNestedPublic(System.Type)">
            <summary>Checks if type is public or nested public in public type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsClass(System.Type)">
            <summary>Returns true if type is class.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsValueType(System.Type)">
            <summary>Returns true if type is value type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsInterface(System.Type)">
            <summary>Returns true if type is interface.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsAbstract(System.Type)">
            <summary>Returns true if type if abstract or interface.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsStatic(System.Type)">
            <summary>Returns true if type is static.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsEnum(System.Type)">
            <summary>Returns true if type is enum type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.HasConversionOperatorTo(System.Type,System.Type)">
            <summary>Returns true if type can be casted with conversion operators.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetSourceConversionOperatorToTarget(System.Type,System.Type)">
            Returns `target source.op_(Explicit|Implicit)(source)` or null if not found
        </member>
        <member name="M:DryIoc.ReflectionTools.GetTargetConversionOperatorFromSource(System.Type,System.Type)">
            Returns `target target.op_(Explicit|Implicit)(source)` or null if not found
        </member>
        <member name="M:DryIoc.ReflectionTools.IsAssignableTo(System.Type,System.Type)">
            <summary>Returns true if type is assignable to <paramref name="other"/> type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsAssignableTo``1(System.Type)">
            <summary>Returns true if type is assignable to <typeparamref name="T"/> type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsAssignableVariantGenericTypeFrom(System.Type,System.Type)">
            <summary>`to` should be the closed-generic type</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsTypeOf(System.Type,System.Object)">
            <summary>Returns true if type of <paramref name="obj"/> is assignable to source <paramref name="type"/>.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsPrimitive(System.Type,System.Boolean)">
            <summary>Returns true if provided type IsPrimitive in .Net terms, or enum, or string,
            or array of primitives if <paramref name="orArrayOfPrimitives"/> is true.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAttributes(System.Type,System.Type,System.Boolean)">
            <summary>Returns all attributes defined on <paramref name="type"/>.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetMembers``1(System.Type,System.Func{System.Reflection.TypeInfo,System.Collections.Generic.IEnumerable{``0}},System.Boolean)">
            <summary>Recursive method to enumerate all input type and its base types for specific details.
            Details are returned by <paramref name="getMembers"/> delegate.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.PublicConstructors(System.Type)">
            <summary>Returns all public instance constructors for the type</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.PublicAndInternalConstructors(System.Type)">
            <summary>Returns all public instance constructors for the type</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.Constructors(System.Type,System.Boolean,System.Boolean)">
            <summary>Enumerates all constructors from input type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetConstructorOrNull(System.Type,System.Boolean,System.Type[])">
            <summary>Searches and returns the first constructor by its signature, e.g. with the same number of parameters of the same type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetConstructorOrNull(System.Type,System.Type[])">
            <summary>Searches and returns constructor by its signature.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.Constructor(System.Type,System.Type[])">
            <summary>Searches and returns constructor by its signature, or throws if not found</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetSingleConstructorOrNull(System.Type,System.Boolean)">
            <summary>Returns single constructor otherwise (if no constructor or more than one) returns null.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.SingleConstructor(System.Type,System.Boolean)">
            <summary>Returns single constructor otherwise (if no or more than one) throws an exception</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetSingleMethodOrNull(System.Type,System.String,System.Boolean)">
            <summary>Looks up for single declared method with the specified name. Returns null if method is not found.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.SingleMethod(System.Type,System.String,System.Boolean)">
            <summary>Looks for single declared (not inherited) method by name, and throws if not found.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.Method(System.Type,System.String,System.Type[])">
            <summary>Looks up for method with and specified parameter types.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetMethodOrNull(System.Type,System.String,System.Type[])">
            <summary>Looks up for method with and specified parameter types.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.Property(System.Type,System.String,System.Boolean)">
            <summary>Returns property by name, including inherited. Or null if not found.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetPropertyOrNull(System.Type,System.String,System.Boolean)">
            <summary>Returns property by name, including inherited. Or null if not found.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.Field(System.Type,System.String,System.Boolean)">
            <summary>Returns field by name, including inherited. Or null if not found.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetFieldOrNull(System.Type,System.String,System.Boolean)">
            <summary>Returns field by name, including inherited. Or null if not found.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAssembly(System.Type)">
            <summary>Returns type assembly.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsExplicitlyImplemented(System.Reflection.PropertyInfo)">
            <summary>Is <c>true</c> for interface declared property explicitly implemented, e.g. <c>IInterface.Prop</c></summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsStatic(System.Reflection.MemberInfo)">
            <summary>Returns true if member is static, otherwise returns false.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsStatic(System.Reflection.PropertyInfo,System.Boolean)">
            Find if property is static
        </member>
        <member name="M:DryIoc.ReflectionTools.GetReturnTypeOrDefault(System.Reflection.MemberInfo)">
            <summary>Return either <see cref="P:System.Reflection.PropertyInfo.PropertyType"/>, or <see cref="P:System.Reflection.FieldInfo.FieldType"/>, 
            <see cref="P:System.Reflection.MethodInfo.ReturnType"/>.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsBackingField(System.Reflection.FieldInfo)">
            <summary>Returns true if field is backing field for property.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsIndexer(System.Reflection.PropertyInfo)">
            <summary>Returns true if property is indexer: aka this[].</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsClosureType(System.Type)">
            <summary>Returns true if type is generated type of hoisted closure.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAttributes(System.Reflection.MemberInfo,System.Type,System.Boolean)">
            <summary>Returns attributes defined for the member/method.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAttributes(System.Reflection.ParameterInfo,System.Type,System.Boolean)">
            <summary>Returns attributes defined for parameter.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetLoadedTypes(System.Reflection.Assembly)">
            <summary>Get types from assembly that are loaded successfully.
            Hacks the <see cref="T:System.Reflection.ReflectionTypeLoadException"/>to get failing to load types metadata.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetDefaultValueExpression(System.Type)">
            <summary>Creates default(T) expression for provided <paramref name="type"/>.</summary>
        </member>
        <member name="T:DryIoc.PrintTools">
            <summary>Provides pretty printing/debug view for number of types.</summary>
        </member>
        <member name="F:DryIoc.PrintTools.DefaultItemSeparator">
            <summary>Default separator used for printing enumerable.</summary>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.Object,System.String,System.String,System.Func{System.Type,System.String})">
            <summary>Prints input object by using corresponding Print methods for know types.</summary>
            <param name="s">Builder to append output to.</param> <param name="x">Object to print.</param>
            <param name="quote">(optional) Quote to use for quoting string object.</param>
            <param name="itemSeparator">(optional) Separator for enumerable.</param>
            <param name="getTypeName">(optional) Custom type printing policy.</param>
            <returns>String builder with appended output.</returns>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.String,System.String)">
            <summary>Appends string to string builder quoting with <paramref name="quote"/> if provided.</summary>
            <param name="s">String builder to append string to.</param> <param name="str">String to print.</param>
            <param name="quote">(optional) Quote to add before and after string.</param>
            <returns>String builder with appended string.</returns>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.Collections.IEnumerable,System.String,System.Action{System.Text.StringBuilder,System.Object})">
            <summary>Prints enumerable by using corresponding Print method for known item type.</summary>
            <param name="s">String builder to append output to.</param>
            <param name="items">Items to print.</param>
            <param name="separator">(optional) Custom separator if provided.</param>
            <param name="printItem">(optional) Custom item printer if provided.</param>
            <returns>String builder with appended output.</returns>
        </member>
        <member name="F:DryIoc.PrintTools.GetTypeNameDefault">
            <summary>Default delegate to print Type details: by default prints Type FullName and
            skips namespace if it start with "System."</summary>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.Type,System.Func{System.Type,System.String})">
            <summary>Pretty prints the <paramref name="type"/> in proper C# representation.
            <paramref name="getTypeName"/>Allows to specify if you want Name instead of FullName.</summary>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Type,System.Func{System.Type,System.String})">
            <summary>Pretty-prints the type</summary>
        </member>
        <member name="T:DryIoc.Portable">
            <summary>Ports some methods from .Net 4.0/4.5</summary>
            Something for portability
        </member>
        <member name="M:DryIoc.Portable.GetAssemblyTypes(System.Reflection.Assembly)">
            <summary>Portable version of Assembly.GetTypes or Assembly.DefinedTypes.</summary>
        </member>
        <member name="M:DryIoc.Portable.GetGetMethodOrNull(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>Portable version of PropertyInfo.GetGetMethod.</summary>
        </member>
        <member name="M:DryIoc.Portable.GetSetMethodOrNull(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>Portable version of PropertyInfo.GetSetMethod.</summary>
        </member>
        <member name="M:DryIoc.Portable.GetCurrentManagedThreadID">
            <summary>Returns managed Thread ID either from Environment or Thread.CurrentThread whichever is available.</summary>
        </member>
        <member name="T:System.Reflection.TypeInfoTools">
            <summary>Provides <see cref="M:System.Reflection.TypeInfoTools.GetTypeInfo(System.Type)"/> for the type.</summary>
        </member>
        <member name="M:System.Reflection.TypeInfoTools.GetTypeInfo(System.Type)">
            <summary>Wraps input type into <see cref="T:System.Reflection.TypeInfo"/> structure.</summary>
            <param name="type">Input type.</param> <returns>Type info wrapper.</returns>
        </member>
        <member name="T:System.Reflection.TypeInfo">
            <summary>Partial analog of TypeInfo existing in .NET 4.5 and higher.</summary>
        </member>
        <member name="M:System.Reflection.TypeInfo.#ctor(System.Type)">
            <summary>Creates type info by wrapping input type.</summary> <param name="type">Type to wrap.</param>
        </member>
        <member name="T:FastExpressionCompiler.LightExpression.ExpressionCompiler">
            <summary>Polyfill for absence of FastExpressionCompiler: https://github.com/dadhi/FastExpressionCompiler </summary>
        </member>
        <member name="T:ImTools.Fun">
            <summary>Helpers for functional composition</summary>
        </member>
        <member name="M:ImTools.Fun.Always``1(``0)">
            <summary>
            Always a true condition.
            </summary> 
        </member>
        <member name="M:ImTools.Fun.Id``1(``0)">
            <summary>
            Identity function returning passed argument as result.
            </summary> 
        </member>
        <member name="M:ImTools.Fun.To``2(``0,System.Func{``0,``1})">
            <summary>
            Forward pipe operator (`|>` in F#)
            </summary> 
        </member>
        <member name="M:ImTools.Fun.To``3(``0,``1,System.Func{``0,``1,``2})">
            <summary>
            Forward pipe operator (`|>` in F#) with the additional state A for two arguments function
            </summary> 
        </member>
        <member name="M:ImTools.Fun.To``1(System.Object)">
            <summary>
            Cast to the R type with the forward pipe operator (`|>` in F#)
            </summary> 
        </member>
        <member name="M:ImTools.Fun.Do``1(``0,System.Action{``0})">
            <summary>
            Forward pipe operator (`|>` in F#) but with side effect propagating the original `x` value
            </summary> 
        </member>
        <member name="M:ImTools.Fun.Do``2(``0,``1,System.Action{``0,``1})">
            <summary>
            Forward pipe operator (`|>` in F#) but with side effect propagating the original `x` value and the state object
            </summary> 
        </member>
        <member name="M:ImTools.Fun.ToFunc``2(``1,``0)">
            <summary>
            Lifts argument to Func without allocations ignoring the first argument.
            For example if you have `Func{T, R} = _ => instance`,
            you may rewrite it without allocations as `instance.ToFunc{A, R}`
            </summary> 
        </member>
        <member name="T:ImTools.Lazy">
            <summary>Helpers for lazy instantiations</summary>
        </member>
        <member name="M:ImTools.Lazy.Of``1(System.Func{``0})">
            <summary>Provides result type inference for creation of lazy.</summary>
        </member>
        <member name="T:ImTools.Unit">
            Replacement for `Void` type which can be used as a type argument and value.
            In traditional functional languages this type is a singleton empty record type,
            e.g. `()` in Haskell https://en.wikipedia.org/wiki/Unit_type
        </member>
        <member name="F:ImTools.Unit.unit">
            Singleton unit value - making it a lower-case so you could import `using static ImTools.Unit;` and write `return unit;`
        </member>
        <member name="M:ImTools.Unit.ToString">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Unit.Equals(ImTools.Unit)">
            Equals to any other Unit
        </member>
        <member name="M:ImTools.Unit.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Unit.GetHashCode">
            Using type hash code for the value
        </member>
        <member name="T:ImTools.I`1">
            Simple value provider interface - useful for the type pattern matching via `case I{T} x: ...`
        </member>
        <member name="P:ImTools.I`1.Value">
            The value in this case ;)
        </member>
        <member name="T:ImTools.UnionTools">
            Helpers for `Is` and `Union`
        </member>
        <member name="M:ImTools.UnionTools.ToString``2(``1,System.String,System.String)">
            Pretty prints the Union using the type information
        </member>
        <member name="T:ImTools.Item`2">
            Wraps the `T` in a typed `TData` struct value in a one-line declaration,
            so the <c><![CDATA[class Name : Case<Name, string>]]></c>
            is different from the <c><![CDATA[class Address : Case<Address, string>]]></c> 
        </member>
        <member name="M:ImTools.Item`2.Of(`1)">
            Creation method for the consistency with other types
        </member>
        <member name="T:ImTools.Item`2.item">
            Nested structure that hosts a value.
            All nested types by convention here are lowercase
        </member>
        <member name="P:ImTools.Item`2.item.Value">
            <inheritdoc />
        </member>
        <member name="F:ImTools.Item`2.item.Item">
            The value
        </member>
        <member name="M:ImTools.Item`2.item.#ctor(`1)">
            Constructor
        </member>
        <member name="M:ImTools.Item`2.item.Equals(ImTools.Item{`0,`1}.item)">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Item`2.item.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Item`2.item.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Item`2.item.ToString">
            <inheritdoc />
        </member>
        <member name="T:ImTools.Item`1">
            Item without the data payload
        </member>
        <member name="F:ImTools.Item`1.Single">
            Single item value
        </member>
        <member name="T:ImTools.Item`1.item">
            Nested structure that hosts a value.
            All nested types by convention here are lowercase
        </member>
        <member name="M:ImTools.Item`1.item.Equals(ImTools.Item{`0}.item)">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Item`1.item.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Item`1.item.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Item`1.item.ToString">
            <inheritdoc />
        </member>
        <member name="T:ImTools.Box`2">
            Wraps the `T` in a named `TBox` class in a one-line declaration,
            so the <c><![CDATA[class Name : Data<Name, string>]]></c>
            is different from the <c><![CDATA[class Address : Data<Address, string>]]></c> 
        </member>
        <member name="M:ImTools.Box`2.Of(`1)">
            Wraps the value
        </member>
        <member name="P:ImTools.Box`2.Value">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Box`2.Equals(ImTools.Box{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Box`2.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Box`2.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Box`2.ToString">
            <inheritdoc />
        </member>
        <member name="T:ImTools.U`2">
            Unnamed discriminated union (with Empty name), shorter name for simplified inline usage
        </member>
        <member name="T:ImTools.Union`3">
            Discriminated union
        </member>
        <member name="T:ImTools.Union`3.Tag">
            To tag the cases with enum value for efficient pattern matching of required -
            otherwise we need to use `is CaseN` pattern or similar which is less efficient
        </member>
        <member name="F:ImTools.Union`3.Tag.Case1">
            Tags Case1
        </member>
        <member name="F:ImTools.Union`3.Tag.Case2">
            Tags Case2
        </member>
        <member name="T:ImTools.Union`3.union">
            The base interface for the cases to operate.
            The naming is selected to start from the lower letter, cause we need to use the nested type.
            It is an unusual case, that's why using the __union__ will be fine to highlight this.
        </member>
        <member name="P:ImTools.Union`3.union.Tag">
            The tag
        </member>
        <member name="M:ImTools.Union`3.union.Match``1(System.Func{`1,``0},System.Func{`2,``0})">
            Matches the union cases to the R value
        </member>
        <member name="M:ImTools.Union`3.Of(`1)">
            Creates the respective case
        </member>
        <member name="M:ImTools.Union`3.Of(`2)">
            Creates the respective case
        </member>
        <member name="T:ImTools.Union`3.case1">
            Wraps the respective case
        </member>
        <member name="M:ImTools.Union`3.case1.op_Implicit(`1)~ImTools.Union{`0,`1,`2}.case1">
            Implicit conversion
        </member>
        <member name="P:ImTools.Union`3.case1.Tag">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Union`3.case1.Match``1(System.Func{`1,``0},System.Func{`2,``0})">
            <inheritdoc />
        </member>
        <member name="P:ImTools.Union`3.case1.Value">
            <inheritdoc />
        </member>
        <member name="F:ImTools.Union`3.case1.Case">
            The case value
        </member>
        <member name="M:ImTools.Union`3.case1.#ctor(`1)">
            Wraps the value
        </member>
        <member name="M:ImTools.Union`3.case1.Equals(ImTools.Union{`0,`1,`2}.case1)">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Union`3.case1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Union`3.case1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Union`3.case1.ToString">
            <inheritdoc />
        </member>
        <member name="T:ImTools.Union`3.case2">
            Wraps the respective case
        </member>
        <member name="M:ImTools.Union`3.case2.op_Implicit(`2)~ImTools.Union{`0,`1,`2}.case2">
            Conversion
        </member>
        <member name="P:ImTools.Union`3.case2.Tag">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Union`3.case2.Match``1(System.Func{`1,``0},System.Func{`2,``0})">
            <inheritdoc />
        </member>
        <member name="P:ImTools.Union`3.case2.Value">
            <inheritdoc />
        </member>
        <member name="F:ImTools.Union`3.case2.Case">
            The case value
        </member>
        <member name="M:ImTools.Union`3.case2.#ctor(`2)">
            Wraps the value
        </member>
        <member name="M:ImTools.Union`3.case2.Equals(ImTools.Union{`0,`1,`2}.case2)">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Union`3.case2.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Union`3.case2.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:ImTools.Union`3.case2.ToString">
            <inheritdoc />
        </member>
        <member name="T:ImTools.ArrayTools">
            <summary>Methods to work with immutable arrays and some sugar.</summary>
        </member>
        <member name="M:ImTools.ArrayTools.Empty``1">
            <summary>Returns singleton empty array of provided type.</summary> 
            <typeparam name="T">Array item type.</typeparam> <returns>Empty array.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.One``1(``0)">
            <summary>Wraps item in array.</summary>
        </member>
        <member name="M:ImTools.ArrayTools.IsNullOrEmpty``1(``0[])">
            <summary>Returns true if array is null or have no items.</summary> <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Source array to check.</param> <returns>True if null or has no items, false otherwise.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.EmptyIfNull``1(``0[])">
            <summary>Returns empty array instead of null, or source array otherwise.</summary> <typeparam name="T">Type of array item.</typeparam>
        </member>
        <member name="M:ImTools.ArrayTools.ToArrayOrSelf``1(System.Collections.Generic.IEnumerable{``0})">
            Returns source enumerable if it is array, otherwise converts source to array or an empty array if null.
        </member>
        <member name="M:ImTools.ArrayTools.ToListOrSelf``1(System.Collections.Generic.IEnumerable{``0})">
            Returns source enumerable if it is list, otherwise converts source to IList or an empty array if null.
        </member>
        <member name="M:ImTools.ArrayTools.Copy``1(``0[])">
            <summary>Array copy</summary>
        </member>
        <member name="M:ImTools.ArrayTools.Append``1(``0[],``0[])">
            <summary>Returns new array consisting from all items from source array then all items from added array.
            If source is null or empty, then added array will be returned.
            If added is null or empty, then source will be returned.</summary>
            <typeparam name="T">Array item type.</typeparam>
            <param name="source">Array with leading items.</param>
            <param name="added">Array with following items.</param>
            <returns>New array with items of source and added arrays.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Append``1(``0[],``0)">
            <summary>Append a single item value at the end of source array and returns its copy</summary>
        </member>
        <member name="M:ImTools.ArrayTools.Append``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Performant concat of enumerables in case of arrays.
            But performance will degrade if you use Concat().Where().</summary>
            <typeparam name="T">Type of item.</typeparam>
            <param name="source">goes first.</param>
            <param name="other">appended to source.</param>
            <returns>empty array or concat of source and other.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.AppendOrUpdate``1(``0[],``0,System.Int32)">
            <summary>Returns new array with <paramref name="value"/> appended, 
            or <paramref name="value"/> at <paramref name="index"/>, if specified.
            If source array could be null or empty, then single value item array will be created despite any index.</summary>
            <typeparam name="T">Array item type.</typeparam>
            <param name="source">Array to append value to.</param>
            <param name="value">Value to append.</param>
            <param name="index">(optional) Index of value to update.</param>
            <returns>New array with appended or updated value.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.IndexOf``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Calls predicate on each item in <paramref name="source"/> array until predicate returns true,
            then method will return this item index, or if predicate returns false for each item, method will return -1.</summary>
            <typeparam name="T">Type of array items.</typeparam>
            <param name="source">Source array: if null or empty, then method will return -1.</param>
            <param name="predicate">Delegate to evaluate on each array item until delegate returns true.</param>
            <returns>Index of item for which predicate returns true, or -1 otherwise.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.IndexOf``2(``0[],``1,System.Func{``1,``0,System.Boolean})">
            Minimizes the allocations for closure in predicate lambda with the provided <paramref name="state"/>
        </member>
        <member name="M:ImTools.ArrayTools.IndexOf``1(``0[],``0)">
            <summary>Looks up for item in source array equal to provided value, and returns its index, or -1 if not found.</summary>
            <typeparam name="T">Type of array items.</typeparam>
            <param name="source">Source array: if null or empty, then method will return -1.</param>
            <param name="value">Value to look up.</param>
            <returns>Index of item equal to value, or -1 item is not found.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.IndexOfReference``1(``0[],``0)">
            <summary>The same as `IndexOf` but searching the item by reference</summary>
        </member>
        <member name="M:ImTools.ArrayTools.RemoveAt``1(``0[],System.Int32)">
            <summary>Produces new array without item at specified <paramref name="index"/>. 
            Will return <paramref name="source"/> array if index is out of bounds, or source is null/empty.</summary>
            <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Input array.</param> <param name="index">Index if item to remove.</param>
            <returns>New array with removed item at index, or input source array if index is not in array.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Remove``1(``0[],``0)">
            <summary>Looks for item in array using equality comparison, and returns new array with found item remove, or original array if not item found.</summary>
            <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Input array.</param> <param name="value">Value to find and remove.</param>
            <returns>New array with value removed or original array if value is not found.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.FindFirst``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Returns first item matching the <paramref name="predicate"/>, or default item value.</summary>
            <typeparam name="T">item type</typeparam>
            <param name="source">items collection to search</param>
            <param name="predicate">condition to evaluate for each item.</param>
            <returns>First item matching condition or default value.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.FindFirst``2(``0[],``1,System.Func{``1,``0,System.Boolean})">
            Version of FindFirst with the fixed state used by predicate to prevent allocations by predicate lambda closure
        </member>
        <member name="M:ImTools.ArrayTools.FindFirst``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Returns first item matching the <paramref name="predicate"/>, or default item value.</summary>
            <typeparam name="T">item type</typeparam>
            <param name="source">items collection to search</param>
            <param name="predicate">condition to evaluate for each item.</param>
            <returns>First item matching condition or default value.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.SingleOrDefaultIfMany``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns element if collection consist on single element, otherwise returns default value.
            It does not throw for collection with many elements</summary>
        </member>
        <member name="M:ImTools.ArrayTools.ForEach``1(``0[],System.Action{``0})">
            <summary>Does <paramref name="action"/> for each item</summary>
        </member>
        <member name="M:ImTools.ArrayTools.AppendTo``1(``0[],System.Int32,System.Int32,``0[])">
            Appends source to results
        </member>
        <member name="M:ImTools.ArrayTools.UpdateItemOrShrinkUnsafe``2(``0[],``1,System.Func{``1,``0,``0})">
            <summary>MUTATES the source by updating its item or creates another array with the copies,
            the source then maybe a partially updated</summary>
        </member>
        <member name="M:ImTools.ArrayTools.Match``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.
            It returns source array and does Not create new one if all items match the condition.</summary>
            <typeparam name="T">Type of source items.</typeparam>
            <param name="source">If null, the null will be returned.</param>
            <param name="condition">Condition to keep items.</param>
            <returns>New array if some items are filter out. Empty array if all items are filtered out. Original array otherwise.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Match``2(``0[],``1,System.Func{``1,``0,System.Boolean})">
            Match with the additional state to use in <paramref name="condition"/> to minimize the allocations in <paramref name="condition"/> lambda closure 
        </member>
        <member name="M:ImTools.ArrayTools.Match``2(``0[],System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.
            It returns source array and does Not create new one if all items match the condition.</summary>
            <typeparam name="T">Type of source items.</typeparam> <typeparam name="R">Type of result items.</typeparam>
            <param name="source">If null, the null will be returned.</param>
            <param name="condition">Condition to keep items.</param> <param name="map">Converter from source to result item.</param>
            <returns>New array of result items.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Match``3(``0[],``1,System.Func{``1,``0,System.Boolean},System.Func{``1,``0,``2})">
            Match with the additional state to use in <paramref name="condition"/> and <paramref name="map"/> to minimize the allocations in <paramref name="condition"/> lambda closure 
        </member>
        <member name="M:ImTools.ArrayTools.Map``2(``0[],System.Func{``0,``1})">
            <summary>Maps all items from source to result array.</summary>
            <typeparam name="T">Source item type</typeparam> <typeparam name="R">Result item type</typeparam>
            <param name="source">Source items</param> <param name="map">Function to convert item from source to result.</param>
            <returns>Converted items</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Map``3(``0[],``1,System.Func{``1,``0,``2})">
            Map with additional state to use in <paramref name="map"/> to minimize allocations in <paramref name="map"/> lambda closure 
        </member>
        <member name="M:ImTools.ArrayTools.Map``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Maps all items from source to result collection. 
            If possible uses fast array Map otherwise Enumerable.Select.</summary>
            <typeparam name="T">Source item type</typeparam> <typeparam name="R">Result item type</typeparam>
            <param name="source">Source items</param> <param name="map">Function to convert item from source to result.</param>
            <returns>Converted items</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Match``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>If <paramref name="source"/> is array uses more effective Match for array, otherwise just calls Where</summary>
        </member>
        <member name="M:ImTools.ArrayTools.Match``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>If <paramref name="source"/> is array uses more effective Match for array,otherwise just calls Where, Select</summary>
        </member>
        <member name="T:ImTools.Ref`1">
            <summary>Wrapper that provides optimistic-concurrency Swap operation implemented using <see cref="M:ImTools.Ref.Swap``1(``0@,System.Func{``0,``0},System.Int32)"/>.</summary>
            <typeparam name="T">Type of object to wrap.</typeparam>
        </member>
        <member name="P:ImTools.Ref`1.Value">
            <summary>Gets the wrapped value.</summary>
        </member>
        <member name="M:ImTools.Ref`1.#ctor(`0)">
            <summary>Creates ref to object, optionally with initial value provided.</summary>
            <param name="initialValue">(optional) Initial value.</param>
        </member>
        <member name="M:ImTools.Ref`1.Swap(System.Func{`0,`0})">
            <summary>Exchanges currently hold object with <paramref name="getNewValue"/> - see <see cref="M:ImTools.Ref.Swap``1(``0@,System.Func{``0,``0},System.Int32)"/> for details.</summary>
            <param name="getNewValue">Delegate to produce new object value from current one passed as parameter.</param>
            <returns>Returns old object value the same way as <see cref="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)"/></returns>
            <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        </member>
        <member name="M:ImTools.Ref`1.Swap``1(``0,System.Func{`0,``0,`0})">
            Option without allocation for capturing `a` in closure of `getNewValue`
        </member>
        <member name="M:ImTools.Ref`1.Swap``2(``0,``1,System.Func{`0,``0,``1,`0})">
            Option without allocation for capturing `a` and `b` in closure of `getNewValue`
        </member>
        <member name="M:ImTools.Ref`1.Swap(`0)">
            <summary>Just sets new value ignoring any intermingled changes and returns the original value</summary>
            <param name="newValue"></param> <returns>old value</returns>
        </member>
        <member name="M:ImTools.Ref`1.SetNonAtomic(`0)">
            <summary>Directly sets the value and returns the new value</summary>
        </member>
        <member name="M:ImTools.Ref`1.TrySwapIfStillCurrent(`0,`0)">
            <summary>Compares current Referred value with <paramref name="currentValue"/> and if equal replaces current with <paramref name="newValue"/></summary>
            <param name="currentValue"></param> <param name="newValue"></param>
            <returns>True if current value was replaced with new value, and false if current value is outdated (already changed by other party).</returns>
            <example><c>[!CDATA[
            var value = SomeRef.Value;
            if (!SomeRef.TrySwapIfStillCurrent(value, Update(value))
                SomeRef.Swap(v => Update(v)); // fallback to normal Swap with delegate allocation
            ]]</c></example>
        </member>
        <member name="T:ImTools.Ref">
            <summary>Provides optimistic-concurrency consistent <see cref="M:ImTools.Ref.Swap``1(``0@,System.Func{``0,``0},System.Int32)"/> operation.</summary>
        </member>
        <member name="F:ImTools.Ref.RETRY_COUNT_UNTIL_THROW">
            The default max retry count - can be overridden by `Swap` optional parameter 
        </member>
        <member name="M:ImTools.Ref.Of``1(``0)">
            <summary>Factory for <see cref="T:ImTools.Ref`1"/> with type of value inference.</summary>
            <typeparam name="T">Type of value to wrap.</typeparam>
            <param name="value">Initial value to wrap.</param>
            <returns>New ref.</returns>
        </member>
        <member name="M:ImTools.Ref.NewRef``1(ImTools.Ref{``0})">
            <summary>Creates new ref to the value of original ref.</summary> <typeparam name="T">Ref value type.</typeparam>
            <param name="original">Original ref.</param> <returns>New ref to original value.</returns>
        </member>
        <member name="M:ImTools.Ref.Swap``1(``0@,System.Func{``0,``0},System.Int32)">
            <summary>First, it evaluates new value using <paramref name="getNewValue"/> function. 
            Second, it checks that original value is not changed. 
            If it is changed it will retry first step, otherwise it assigns new value and returns original (the one used for <paramref name="getNewValue"/>).</summary>
            <typeparam name="T">Type of value to swap.</typeparam>
            <param name="value">Reference to change to new value</param>
            <param name="getNewValue">Delegate to get value from old one.</param>
            <param name="retryCountUntilThrow">(optional)</param>
            <returns>Old/original value. By analogy with <see cref="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)"/>.</returns>
            <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        </member>
        <member name="M:ImTools.Ref.Swap``2(``0@,``1,System.Func{``0,``1,``0},System.Int32)">
            <summary>Swap with the additional state <paramref name="a"/> required for the delegate <paramref name="getNewValue"/>.
            May prevent closure creation for the delegate</summary>
        </member>
        <member name="M:ImTools.Ref.SwapAndGetNewValue``2(``0@,``1,System.Func{``0,``1,``0},System.Int32)">
            <summary>Swap with the additional state <paramref name="a"/> required for the delegate <paramref name="getNewValue"/>.
            May prevent closure creation for the delegate</summary>
        </member>
        <member name="M:ImTools.Ref.Swap``3(``0@,``1,``2,System.Func{``0,``1,``2,``0},System.Int32)">
            <summary>Swap with the additional state <paramref name="a"/>, <paramref name="b"/> required for the delegate <paramref name="getNewValue"/>.
            May prevent closure creation for the delegate</summary>
        </member>
        <member name="M:ImTools.Ref.Swap``4(``0@,``1,``2,``3,System.Func{``0,``1,``2,``3,``0},System.Int32)">
            <summary>Swap with the additional state <paramref name="a"/>, <paramref name="b"/>, <paramref name="c"/> required for the delegate <paramref name="getNewValue"/>.
            May prevent closure creation for the delegate</summary>
        </member>
        <member name="T:ImTools.IPrintable">
            <summary>Printable thing via provided printer </summary>
        </member>
        <member name="M:ImTools.IPrintable.Print(System.Text.StringBuilder,System.Func{System.Text.StringBuilder,System.Object,System.Text.StringBuilder})">
            <summary>Print to the provided string builder via the provided printer.</summary>
        </member>
        <member name="T:ImTools.Hasher">
            <summary>Produces good enough hash codes for the fields</summary>
        </member>
        <member name="M:ImTools.Hasher.Combine``2(``0,``1)">
            <summary>Combines hashes of two fields</summary>
        </member>
        <member name="M:ImTools.Hasher.Combine(System.Int32,System.Int32)">
            <summary>Inspired by System.Tuple.CombineHashCodes</summary>
        </member>
        <member name="T:ImTools.StackPool`1">
            Simple unbounded object pool
        </member>
        <member name="M:ImTools.StackPool`1.RentOrDefault">
            <summary>Give me an object</summary>
        </member>
        <member name="M:ImTools.StackPool`1.Return(`0)">
            <summary>Give it back</summary>
        </member>
        <member name="T:ImTools.KV`2">
            <summary>Immutable Key-Value pair. It is reference type (could be check for null), 
            which is different from System value type <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            In addition provides <see cref="M:ImTools.KV`2.Equals(System.Object)"/> and <see cref="M:ImTools.KV`2.GetHashCode"/> implementations.</summary>
            <typeparam name="K">Type of Key.</typeparam><typeparam name="V">Type of Value.</typeparam>
        </member>
        <member name="F:ImTools.KV`2.Key">
            <summary>Key.</summary>
        </member>
        <member name="F:ImTools.KV`2.Value">
            <summary>Value.</summary>
        </member>
        <member name="M:ImTools.KV`2.#ctor(`0,`1)">
            <summary>Creates Key-Value object by providing key and value. Does Not check either one for null.</summary>
            <param name="key">key.</param><param name="value">value.</param>
        </member>
        <member name="M:ImTools.KV`2.Print(System.Text.StringBuilder,System.Func{System.Text.StringBuilder,System.Object,System.Text.StringBuilder})">
            <inheritdoc />
        </member>
        <member name="M:ImTools.KV`2.ToString">
            <summary>Creates nice string view.</summary><returns>String representation.</returns>
        </member>
        <member name="M:ImTools.KV`2.Equals(System.Object)">
            <summary>Returns true if both key and value are equal to corresponding key-value of other object.</summary>
        </member>
        <member name="M:ImTools.KV`2.GetHashCode">
            <summary>Combines key and value hash code</summary>
        </member>
        <member name="T:ImTools.KV">
            <summary>Helpers for <see cref="T:ImTools.KV`2"/>.</summary>
        </member>
        <member name="M:ImTools.KV.Of``2(``0,``1)">
            <summary>Creates the key value pair.</summary>
        </member>
        <member name="M:ImTools.KV.WithValue``2(ImTools.KV{``0,``1},``1)">
            <summary>Creates the pair with the new value</summary>
        </member>
        <member name="T:ImTools.KeyValuePair">
            Simple helper for creation of the pair of two parts.
        </member>
        <member name="M:ImTools.KeyValuePair.Pair``2(``0,``1)">
            Pairs key with value.
        </member>
        <member name="T:ImTools.Opt`1">
            <summary>Helper structure which allows to distinguish null value from the default value for optional parameter.</summary>
        </member>
        <member name="M:ImTools.Opt`1.op_Implicit(`0)~ImTools.Opt{`0}">
            <summary>Allows to transparently convert parameter argument to opt structure.</summary>
        </member>
        <member name="F:ImTools.Opt`1.Value">
            <summary>Argument value.</summary>
        </member>
        <member name="F:ImTools.Opt`1.HasValue">
            <summary>Indicates that value is provided.</summary>
        </member>
        <member name="M:ImTools.Opt`1.#ctor(`0)">
            <summary>Wraps passed value in structure. Sets the flag that value is present.</summary>
        </member>
        <member name="M:ImTools.Opt`1.OrDefault(`0)">
            <summary>Helper to get value or default value if value is not present.</summary>
        </member>
        <member name="T:ImTools.GrowingList`1">
            <summary>Ever growing list</summary>
        </member>
        <member name="F:ImTools.GrowingList`1.DefaultInitialCapacity">
            <summary>Default initial capacity </summary>
        </member>
        <member name="F:ImTools.GrowingList`1.Items">
            The items array
        </member>
        <member name="F:ImTools.GrowingList`1.Count">
            The count
        </member>
        <member name="M:ImTools.GrowingList`1.#ctor(`0[],System.Int32)">
            Constructs the thing 
        </member>
        <member name="M:ImTools.GrowingList`1.PushSlot">
            Push the new slot and return the ref to it
        </member>
        <member name="M:ImTools.GrowingList`1.PushSlot(`0)">
            Adds the new item possibly extending the item collection
        </member>
        <member name="M:ImTools.GrowingList`1.Pop">
            Pops the item - just moving the counter back
        </member>
        <member name="M:ImTools.GrowingList`1.Expand(`0[])">
            Expands the items starting with 2
        </member>
        <member name="M:ImTools.GrowingList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:ImTools.ImList`1">
            <summary>Immutable list - simplest linked list with the Head and the Tail.</summary>
        </member>
        <member name="F:ImTools.ImList`1.Empty">
            <summary>Empty list to Push to.</summary>
        </member>
        <member name="P:ImTools.ImList`1.IsEmpty">
            <summary>True for empty list.</summary>
        </member>
        <member name="F:ImTools.ImList`1.Head">
            <summary>First value in a list.</summary>
        </member>
        <member name="F:ImTools.ImList`1.Tail">
            <summary>The rest of values or Empty if list has a single value.</summary>
        </member>
        <member name="M:ImTools.ImList`1.Push(`0)">
            <summary>Prepends new value and returns new list.</summary>
        </member>
        <member name="M:ImTools.ImList`1.Enumerate">
            <summary>Enumerates the list.</summary>
        </member>
        <member name="M:ImTools.ImList`1.ToString">
            <summary>String representation for debugging purposes</summary>
        </member>
        <member name="T:ImTools.ImList">
            <summary>Extension methods providing basic operations on a list.</summary>
        </member>
        <member name="M:ImTools.ImList.Deconstruct``1(ImTools.ImList{``0},``0@,ImTools.ImList{``0}@,System.Boolean@)">
            Split list into (Head, Tail, IsEmpty) tuple
        </member>
        <member name="M:ImTools.ImList.List``1(``0[])">
            <summary>
            Constructs the reversed list from the parameter array of items
            </summary>
        </member>
        <member name="M:ImTools.ImList.ToImList``1(System.Collections.Generic.IList{``0})">
            <summary>
            Constructs the list as the reversed input list
            </summary>
        </member>
        <member name="M:ImTools.ImList.ToImList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Constructs the list as the reversed enumerable
            </summary>
        </member>
        <member name="M:ImTools.ImList.List``1(``0)">
            <summary>Constructs list of one element</summary>
        </member>
        <member name="M:ImTools.ImList.List``1(``0,ImTools.ImList{``0})">
            <summary>Constructs list from head and tail</summary>
        </member>
        <member name="M:ImTools.ImList.ForEach``1(ImTools.ImList{``0},System.Action{``0})">
            <summary>Apples some effect action to each element</summary>
        </member>
        <member name="M:ImTools.ImList.Fold``2(ImTools.ImList{``0},``1,System.Func{``0,``1,``1})">
            <summary>Fold list to a single value. The respective name for it in LINQ is Aggregate</summary>
        </member>
        <member name="M:ImTools.ImList.Fold``2(ImTools.ImList{``0},``1,System.Func{``0,System.Int32,``1,``1})">
            <summary>Fold list to a single value with index of item. The respective name for it in LINQ is Aggregate.</summary>
        </member>
        <member name="M:ImTools.ImList.Reverse``1(ImTools.ImList{``0})">
            <summary>Returns new list in reverse order.</summary>
        </member>
        <member name="M:ImTools.ImList.Map``2(ImTools.ImList{``0},System.Func{``0,``1})">
            <summary>Maps the items from the first list to the result list.</summary>
        </member>
        <member name="M:ImTools.ImList.Map``2(ImTools.ImList{``0},System.Func{``0,System.Int32,``1})">
            <summary>Maps with index</summary>
        </member>
        <member name="M:ImTools.ImList.ToArray``1(ImTools.ImList{``0})">
            <summary>Copies list to array.</summary>
        </member>
        <member name="T:ImTools.ImZipper`1">
            Zipper is an immutable persistent data structure, to represent collection with single focused (selected, active) element.
            Consist of REVERSED `Left` immutable list, `Focus` element, and the `Right` immutable list. That's why a Zipper name,
            where left and right part are joined / zipped in focus item.
        </member>
        <member name="F:ImTools.ImZipper`1.Empty">
            Empty singleton instance to start building your zipper
        </member>
        <member name="P:ImTools.ImZipper`1.IsEmpty">
            True is zipper does not contain items
        </member>
        <member name="F:ImTools.ImZipper`1.Index">
            Index of Focus item, from `0` to `Count-1`
        </member>
        <member name="F:ImTools.ImZipper`1.Count">
            Number of items
        </member>
        <member name="F:ImTools.ImZipper`1.Left">
            Left REVERSED list, so the Head of the list is just prior the Focus item 
        </member>
        <member name="F:ImTools.ImZipper`1.Right">
            Right list, where Head is just after the Focus item
        </member>
        <member name="F:ImTools.ImZipper`1.Focus">
            Single focus item
        </member>
        <member name="M:ImTools.ImZipper`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:ImTools.ImZipper`1.Append(`0)">
            Sets a new focus and pushes the old focus to the Left list. 
        </member>
        <member name="M:ImTools.ImZipper`1.PushLeft(`0)">
            Sets a new focus and pushes the old focus to the Left list.
        </member>
        <member name="M:ImTools.ImZipper`1.Insert(`0)">
            Sets a new focus and pushes the old focus to the right list. 
        </member>
        <member name="M:ImTools.ImZipper`1.PushRight(`0)">
            Sets a new focus and pushes the old focus to the right list. 
        </member>
        <member name="M:ImTools.ImZipper`1.PopLeft">
            Removes a focus, filling the hole with the item from the left list, or from the right if the left is empty
        </member>
        <member name="M:ImTools.ImZipper`1.PopRight">
            Removes a focus, filling the hole with the item from the right list, or from the left if the right is empty
        </member>
        <member name="M:ImTools.ImZipper`1.ShiftLeft">
            Shifts focus one element to the left (decrementing its Index).
        </member>
        <member name="M:ImTools.ImZipper`1.ShiftRight">
            Shifts focus one element to the right (incrementing its Index).
        </member>
        <member name="M:ImTools.ImZipper`1.WithFocus(`0)">
            Sets a new focus and returns a new zipper with the left and right lists unchanged
        </member>
        <member name="M:ImTools.ImZipper`1.Map``1(System.Func{`0,``0})">
            Maps over the zipper items producing a new zipper
        </member>
        <member name="M:ImTools.ImZipper`1.Map``1(System.Func{`0,System.Int32,``0})">
            Maps over the zipper items with item index, producing a new zipper
        </member>
        <member name="T:ImTools.ImZipper">
            Other ImZipper methods
        </member>
        <member name="M:ImTools.ImZipper.Zip``1(``0[])">
            Appends array items to zipper
        </member>
        <member name="M:ImTools.ImZipper.ToArray``1(ImTools.ImZipper{``0})">
            Converts to array.
        </member>
        <member name="M:ImTools.ImZipper.ShiftTo``1(ImTools.ImZipper{``0},System.Int32)">
            Shifts focus to a specified index, e.g. a random access
        </member>
        <member name="M:ImTools.ImZipper.Update``1(ImTools.ImZipper{``0},System.Func{``0,``0})">
            Updates a focus element if it is present, otherwise does nothing.
            If the focus item is the equal one, then returns the same zipper back.
        </member>
        <member name="M:ImTools.ImZipper.UpdateAt``1(ImTools.ImZipper{``0},System.Int32,System.Func{``0,``0})">
            Update the item at random index, by shifting and updating it
        </member>
        <member name="M:ImTools.ImZipper.RemoveAt``1(ImTools.ImZipper{``0},System.Int32)">
            Update the item at random index, by shifting and updating it
        </member>
        <member name="M:ImTools.ImZipper.Fold``2(ImTools.ImZipper{``0},``1,System.Func{``0,``1,``1})">
            Folds zipper to a single value
        </member>
        <member name="M:ImTools.ImZipper.Fold``2(ImTools.ImZipper{``0},``1,System.Func{``0,System.Int32,``1,``1})">
            Folds zipper to a single value by using an item index
        </member>
        <member name="M:ImTools.ImZipper.ForEach``1(ImTools.ImZipper{``0},System.Action{``0})">
            <summary>Apply some effect action on each element</summary>
        </member>
        <member name="T:ImTools.Update`1">
            Given the old value should and the new value should return result updated value.
        </member>
        <member name="T:ImTools.Update`2">
            Update handler including the key
        </member>
        <member name="T:ImTools.IFoldReducer`2">
            <summary>
            Fold reducer. Designed as a alternative to `Func{V, S, S}` but with possibility of inlining on the call side.
            Note: To get the advantage of inlining the <see cref="M:ImTools.IFoldReducer`2.Reduce(`0,`1)"/> can the interface should be implemented and passed as a NON-GENERIC STRUCT
            </summary>
        </member>
        <member name="M:ImTools.IFoldReducer`2.Reduce(`0,`1)">
            <summary>Reduce method</summary>
        </member>
        <member name="T:ImTools.ImMap`1">
            <summary>
            Immutable http://en.wikipedia.org/wiki/AVL_tree with integer keys and <typeparamref name="V"/> values.
            </summary>
        </member>
        <member name="F:ImTools.ImMap`1.Empty">
            <summary>Empty tree to start with.</summary>
        </member>
        <member name="P:ImTools.ImMap`1.IsEmpty">
            <summary>Returns true if tree is empty.</summary>
        </member>
        <member name="M:ImTools.ImMap`1.#ctor">
            Prevents multiple creation of an empty tree
        </member>
        <member name="P:ImTools.ImMap`1.Height">
            <summary>Height of the longest sub-tree/branch - 0 for the empty tree</summary>
        </member>
        <member name="M:ImTools.ImMap`1.ToString">
            <summary>Prints "empty"</summary>
        </member>
        <member name="T:ImTools.ImMapEntry`1">
            <summary>Wraps the stored data with "fixed" reference semantics - when added to the tree it did not change or reconstructed in memory</summary>
        </member>
        <member name="P:ImTools.ImMapEntry`1.Height">
            <inheritdoc />
        </member>
        <member name="F:ImTools.ImMapEntry`1.Key">
            The Key is basically the hash, or the Height for ImMapTree
        </member>
        <member name="F:ImTools.ImMapEntry`1.Value">
            The value - may be modified if you need a Ref{V} semantics
        </member>
        <member name="M:ImTools.ImMapEntry`1.#ctor(System.Int32)">
            <summary>Constructs the entry with the default value</summary>
        </member>
        <member name="M:ImTools.ImMapEntry`1.#ctor(System.Int32,`0)">
            <summary>Constructs the entry</summary>
        </member>
        <member name="M:ImTools.ImMapEntry`1.ToString">
            Prints the key value pair
        </member>
        <member name="T:ImTools.ImMapBranch`1">
            <summary>
            The two level - two node tree with either left or right
            </summary>
        </member>
        <member name="P:ImTools.ImMapBranch`1.Height">
            <summary>Always two</summary>
        </member>
        <member name="F:ImTools.ImMapBranch`1.Entry">
            Contains the once created data node
        </member>
        <member name="F:ImTools.ImMapBranch`1.RightEntry">
            Right branch or empty.
        </member>
        <member name="M:ImTools.ImMapBranch`1.#ctor(ImTools.ImMapEntry{`0},ImTools.ImMapEntry{`0})">
            Constructor
        </member>
        <member name="M:ImTools.ImMapBranch`1.ToString">
            Prints the key value pair
        </member>
        <member name="T:ImTools.ImMapTree`1">
            <summary>
            The tree always contains Left and Right node, for the missing leaf we have <see cref="T:ImTools.ImMapBranch`1"/>
            </summary>
        </member>
        <member name="P:ImTools.ImMapTree`1.Height">
            Starts from 2
        </member>
        <member name="F:ImTools.ImMapTree`1.TreeHeight">
            Starts from 2 - allows to access the field directly when you know it is a Tree
        </member>
        <member name="F:ImTools.ImMapTree`1.Entry">
            Contains the once created data node
        </member>
        <member name="F:ImTools.ImMapTree`1.Left">
            Left sub-tree/branch, or empty.
        </member>
        <member name="F:ImTools.ImMapTree`1.Right">
            Right sub-tree/branch, or empty.md
        </member>
        <member name="M:ImTools.ImMapTree`1.ToString">
            <summary>Outputs the brief tree info - mostly for debugging purposes</summary>
        </member>
        <member name="M:ImTools.ImMapTree`1.AddOrUpdateLeftOrRightEntry(System.Int32,ImTools.ImMapEntry{`0})">
            <summary>Adds or updates the left or right branch</summary>
        </member>
        <member name="M:ImTools.ImMapTree`1.AddUnsafeLeftOrRightEntry(System.Int32,ImTools.ImMapEntry{`0})">
            <summary>Adds the left or right branch</summary>
        </member>
        <member name="M:ImTools.ImMapTree`1.AddOrKeepLeftOrRight(System.Int32,`0)">
            <summary>Adds to the left or right branch, or keeps the un-modified map</summary>
        </member>
        <member name="M:ImTools.ImMapTree`1.AddOrKeepLeftOrRight(System.Int32)">
            <summary>Adds to the left or right branch, or keeps the un-modified map</summary>
        </member>
        <member name="M:ImTools.ImMapTree`1.AddOrKeepLeftOrRightEntry(System.Int32,ImTools.ImMapEntry{`0})">
            <summary>Adds to the left or right branch, or keeps the un-modified map</summary>
        </member>
        <member name="T:ImTools.ImMap">
            <summary>ImMap methods</summary>
        </member>
        <member name="M:ImTools.ImMap.AddOrUpdateEntry``1(ImTools.ImMap{``0},ImTools.ImMapEntry{``0})">
            <summary> Adds or updates the value by key in the map, always returns a modified map </summary>
        </member>
        <member name="M:ImTools.ImMap.AddOrUpdate``1(ImTools.ImMap{``0},System.Int32,``0)">
            <summary> Adds or updates the value by key in the map, always returns a modified map </summary>
        </member>
        <member name="M:ImTools.ImMap.AddEntryUnsafe``1(ImTools.ImMap{``0},ImTools.ImMapEntry{``0})">
            <summary> Adds the value by key in the map - ASSUMES that the key is not in the map, always returns a modified map </summary>
        </member>
        <member name="M:ImTools.ImMap.AddOrKeep``1(ImTools.ImMap{``0},System.Int32,``0)">
            <summary> Adds the value for the key or returns the un-modified map if key is already present </summary>
        </member>
        <member name="M:ImTools.ImMap.AddOrKeep``1(ImTools.ImMap{``0},System.Int32)">
            <summary> Adds the entry with default value for the key or returns the un-modified map if key is already present </summary>
        </member>
        <member name="M:ImTools.ImMap.AddOrKeepEntry``1(ImTools.ImMap{``0},ImTools.ImMapEntry{``0})">
            <summary> Adds the entry for the key or returns the un-modified map if key is already present </summary>
        </member>
        <member name="M:ImTools.ImMap.Update``1(ImTools.ImMap{``0},System.Int32,``0)">
            <summary>Returns the new map with the updated value for the key, or the same map if the key was not found.</summary>
        </member>
        <member name="M:ImTools.ImMap.UpdateEntryUnsafe``1(ImTools.ImMap{``0},ImTools.ImMapEntry{``0})">
            <summary>Returns the new map with the updated value for the key, ASSUMES that the key is not in the map.</summary>
        </member>
        <member name="M:ImTools.ImMap.UpdateToDefault``1(ImTools.ImMap{``0},System.Int32)">
            <summary>Returns the new map with the value set to default, or the same map if the key was not found.</summary>
        </member>
        <member name="M:ImTools.ImMap.Contains``1(ImTools.ImMap{``0},System.Int32)">
            <summary> Returns `true` if key is found or `false` otherwise. </summary>
        </member>
        <member name="M:ImTools.ImMap.GetEntryOrDefault``1(ImTools.ImMap{``0},System.Int32)">
            <summary> Returns the entry if key is found or null otherwise. </summary>
        </member>
        <member name="M:ImTools.ImMap.GetSurePresentEntry``1(ImTools.ImMap{``0},System.Int32)">
            <summary>Looks for the sure present entry - in cases when we know for certain that the map contains the entry</summary>
        </member>
        <member name="M:ImTools.ImMap.GetValueOrDefault``1(ImTools.ImMap{``0},System.Int32)">
            <summary> Returns the value if key is found or default value otherwise. </summary>
        </member>
        <member name="M:ImTools.ImMap.TryFind``1(ImTools.ImMap{``0},System.Int32,``0@)">
            <summary> Returns true if key is found and sets the value. </summary>
        </member>
        <member name="M:ImTools.ImMap.TryFindEntry``1(ImTools.ImMap{``0},System.Int32,ImTools.ImMapEntry{``0}@)">
            <summary> Returns true if key is found and sets the value. </summary>
        </member>
        <member name="M:ImTools.ImMap.Enumerate``1(ImTools.ImMap{``0},ImTools.ImMapTree{``0}[])">
            <summary>
            Enumerates all the map nodes from the left to the right and from the bottom to top
            You may pass `parentStacks` to reuse the array memory.
            NOTE: the length of `parentStack` should be at least of map (height - 2) - the stack want be used for 0, 1, 2 height maps,
            the content of the stack is not important and could be erased.
            </summary>
        </member>
        <member name="M:ImTools.ImMap.Fold``2(ImTools.ImMap{``0},``1,System.Func{ImTools.ImMapEntry{``0},``1,``1},ImTools.ImMapTree{``0}[])">
            <summary>
            Folds all the map nodes with the state from left to right and from the bottom to top
            You may pass `parentStacks` to reuse the array memory.
            NOTE: the length of `parentStack` should be at least of map (height - 2) - the stack want be used for 0, 1, 2 height maps,
            the content of the stack is not important and could be erased.
            </summary>
        </member>
        <member name="M:ImTools.ImMap.Fold``3(ImTools.ImMap{``0},``1,``2,System.Func{ImTools.ImMapEntry{``0},``1,``2,``1},ImTools.ImMapTree{``0}[])">
            <summary>
            Folds all the map nodes with the state from left to right and from the bottom to top
            You may pass `parentStacks` to reuse the array memory.
            NOTE: the length of `parentStack` should be at least of map (height - 2) - the stack want be used for 0, 1, 2 height maps,
            the content of the stack is not important and could be erased.
            </summary>
        </member>
        <member name="M:ImTools.ImMap.Visit``1(ImTools.ImMap{``0},System.Action{ImTools.ImMapEntry{``0}},ImTools.ImMapTree{``0}[])">
            <summary>
            Visits all the map nodes with from the left to the right and from the bottom to the top
            You may pass `parentStacks` to reuse the array memory.
            NOTE: the length of `parentStack` should be at least of map height, content is not important and could be erased.
            </summary>
        </member>
        <member name="T:ImTools.ImMap.KValue`1">
            <summary>Wraps Key and Value payload to store inside ImMapEntry</summary>
        </member>
        <member name="F:ImTools.ImMap.KValue`1.Key">
            <summary>The key</summary>
        </member>
        <member name="F:ImTools.ImMap.KValue`1.Value">
            <summary>The value</summary>
        </member>
        <member name="M:ImTools.ImMap.KValue`1.#ctor(`0,System.Object)">
            <summary>Constructs a pair</summary>
        </member>
        <member name="M:ImTools.ImMap.AddOrUpdate``1(ImTools.ImMap{ImTools.ImMap.KValue{``0}},System.Int32,``0,System.Object,ImTools.Update{``0,System.Object})">
            <summary>Uses the user provided hash and adds or updates the tree with passed key-value. Returns a new tree.</summary>
        </member>
        <member name="M:ImTools.ImMap.CreateKValueEntry``1(System.Int32,``0,System.Object)">
            <summary>Efficiently creates the new entry</summary>
        </member>
        <member name="M:ImTools.ImMap.CreateKValueEntry``1(System.Int32,``0)">
            <summary>Efficiently creates the new entry</summary>
        </member>
        <member name="M:ImTools.ImMap.AddOrUpdate``1(ImTools.ImMap{ImTools.ImMap.KValue{``0}},System.Int32,``0,System.Object)">
            <summary>Uses the user provided hash and adds or updates the tree with passed key-value. Returns a new tree.</summary>
        </member>
        <member name="M:ImTools.ImMap.AddOrUpdate(ImTools.ImMap{ImTools.ImMap.KValue{System.Type}},System.Type,System.Object)">
            <summary>Adds or updates the Type-keyed entry with the value. Returns a new tree.</summary>
        </member>
        <member name="M:ImTools.ImMap.AddOrUpdate``1(ImTools.ImMap{ImTools.ImMap.KValue{``0}},System.Int32,ImTools.ImMapEntry{ImTools.ImMap.KValue{``0}})">
            <summary>Uses the provided hash and adds or updates the tree with the passed key-value. Returns a new tree.</summary>
        </member>
        <member name="M:ImTools.ImMap.AddOrKeep``1(ImTools.ImMap{ImTools.ImMap.KValue{``0}},System.Int32,``0)">
            <summary>Adds the new entry or keeps the current map if entry key is already present</summary>
        </member>
        <member name="M:ImTools.ImMap.AddOrKeep``1(ImTools.ImMap{ImTools.ImMap.KValue{``0}},System.Int32,``0,System.Object)">
            <summary>Adds the new entry or keeps the current map if entry key is already present</summary>
        </member>
        <member name="M:ImTools.ImMap.Update``1(ImTools.ImMap{ImTools.ImMap.KValue{``0}},System.Int32,``0,System.Object,ImTools.Update{``0,System.Object})">
            <summary>Updates the map with the new value if key is found, otherwise returns the same unchanged map.</summary>
        </member>
        <member name="M:ImTools.ImMap.UpdateToDefault``1(ImTools.ImMap{ImTools.ImMap.KValue{``0}},System.Int32,``0)">
            <summary>Updates the map with the default value if the key is found, otherwise returns the same unchanged map.</summary>
        </member>
        <member name="M:ImTools.ImMap.GetEntryOrDefault``1(ImTools.ImMap{ImTools.ImMap.KValue{``0}},System.Int32,``0)">
            <summary> Returns the entry if key is found or default value otherwise. </summary>
        </member>
        <member name="M:ImTools.ImMap.GetValueOrDefault``1(ImTools.ImMap{ImTools.ImMap.KValue{``0}},System.Int32,``0)">
            <summary> Returns the value if key is found or default value otherwise. </summary>
        </member>
        <member name="M:ImTools.ImMap.TryFind``1(ImTools.ImMap{ImTools.ImMap.KValue{``0}},System.Int32,``0,System.Object@)">
            <summary> Sets the value if key is found or returns false otherwise. </summary>
        </member>
        <member name="M:ImTools.ImMap.GetEntryOrDefault(ImTools.ImMap{ImTools.ImMap.KValue{System.Type}},System.Int32,System.Type)">
            <summary> Returns the entry if key is found or `null` otherwise. </summary>
        </member>
        <member name="M:ImTools.ImMap.GetValueOrDefault(ImTools.ImMap{ImTools.ImMap.KValue{System.Type}},System.Int32,System.Type)">
            <summary> Returns the value if the Type key is found or default value otherwise. </summary>
        </member>
        <member name="M:ImTools.ImMap.GetValueOrDefault(ImTools.ImMap{ImTools.ImMap.KValue{System.Type}},System.Type)">
            <summary> Returns the value if the Type key is found or default value otherwise. </summary>
        </member>
        <member name="M:ImTools.ImMap.Enumerate``1(ImTools.ImMap{ImTools.ImMap.KValue{``0}})">
            <summary>
            Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
            The only difference is using fixed size array instead of stack for speed-up.
            </summary>
        </member>
        <member name="M:ImTools.ImMap.Fold``2(ImTools.ImMap{ImTools.ImMap.KValue{``0}},``1,System.Func{ImTools.ImMapEntry{ImTools.ImMap.KValue{``0}},``1,``1},ImTools.ImMapTree{ImTools.ImMap.KValue{``0}}[])">
            <summary>
            Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
            The only difference is using fixed size array instead of stack for speed-up.
            Note: By passing <paramref name="parentsStack"/> you may reuse the stack array between different method calls,
            but it should be at least <see cref="F:ImTools.ImHashMap`2.Height"/> length. The contents of array are not important.
            </summary>
        </member>
        <member name="M:ImTools.ImMap.Visit``2(ImTools.ImMap{ImTools.ImMap.KValue{``0}},``1,System.Action{ImTools.ImMapEntry{ImTools.ImMap.KValue{``0}},``1},ImTools.ImMapTree{ImTools.ImMap.KValue{``0}}[])">
            <summary>
            Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
            The only difference is using fixed size array instead of stack for speed-up.
            Note: By passing <paramref name="parentsStack"/> you may reuse the stack array between different method calls,
            but it should be at least <see cref="F:ImTools.ImHashMap`2.Height"/> length. The contents of array are not important.
            </summary>
        </member>
        <member name="M:ImTools.ImMap.Visit``1(ImTools.ImMap{ImTools.ImMap.KValue{``0}},System.Action{ImTools.ImMapEntry{ImTools.ImMap.KValue{``0}}},ImTools.ImMapTree{ImTools.ImMap.KValue{``0}}[])">
            <summary>
            Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
            The only difference is using fixed size array instead of stack for speed-up.
            Note: By passing <paramref name="parentsStack"/> you may reuse the stack array between different method calls,
            but it should be at least <see cref="F:ImTools.ImHashMap`2.Height"/> length. The contents of array are not important.
            </summary>
        </member>
        <member name="T:ImTools.ImMapSlots">
            <summary>
            The array of ImMap slots where the key first bits are used for FAST slot location
            and the slot is the reference to ImMap that can be swapped with its updated value
            </summary>
        </member>
        <member name="F:ImTools.ImMapSlots.SLOT_COUNT_POWER_OF_TWO">
            Default number of slots
        </member>
        <member name="F:ImTools.ImMapSlots.KEY_MASK_TO_FIND_SLOT">
            The default mask to partition the key to the target slot
        </member>
        <member name="M:ImTools.ImMapSlots.CreateWithEmpty``1(System.Int32)">
            Creates the array with the empty slots
        </member>
        <member name="M:ImTools.ImMapSlots.AddOrUpdate``1(ImTools.ImMap{``0}[],System.Int32,``0,System.Int32)">
            Returns a new tree with added or updated value for specified key.
        </member>
        <member name="M:ImTools.ImMapSlots.RefAddOrUpdateSlot``1(ImTools.ImMap{``0}@,System.Int32,``0)">
            Update the ref to the slot with the new version - retry if the someone changed the slot in between
        </member>
        <member name="M:ImTools.ImMapSlots.AddOrKeep``1(ImTools.ImMap{``0}[],System.Int32,``0,System.Int32)">
            Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        </member>
        <member name="M:ImTools.ImMapSlots.RefAddOrKeepSlot``1(ImTools.ImMap{``0}@,System.Int32,``0)">
            Update the ref to the slot with the new version - retry if the someone changed the slot in between
        </member>
        <member name="M:ImTools.ImMapSlots.AddOrKeep``1(ImTools.ImMap{``0}[],System.Int32,System.Int32)">
            Adds a default value entry for the specified key or keeps the existing map if the key is already in the map.
        </member>
        <member name="M:ImTools.ImMapSlots.RefAddOrKeepSlot``1(ImTools.ImMap{``0}@,System.Int32)">
            Update the ref to the slot with the new version - retry if the someone changed the slot in between
        </member>
        <member name="M:ImTools.ImMapSlots.Fold``2(ImTools.ImMap{``0}[],``1,System.Func{ImTools.ImMapEntry{``0},``1,``1})">
            <summary> Folds all map nodes without the order </summary>
        </member>
        <member name="T:ImTools.ImHashMapEntry`2">
            <summary>Wraps the stored data with "fixed" reference semantics - when added to the tree it did not change or reconstructed in memory</summary>
        </member>
        <member name="F:ImTools.ImHashMapEntry`2.Empty">
            Empty thingy
        </member>
        <member name="F:ImTools.ImHashMapEntry`2.Hash">
            Key hash
        </member>
        <member name="F:ImTools.ImHashMapEntry`2.Key">
             The key
        </member>
        <member name="F:ImTools.ImHashMapEntry`2.Value">
            The value - may be mutated implementing the Ref CAS semantics if needed
        </member>
        <member name="M:ImTools.ImHashMapEntry`2.#ctor(System.Int32,`0,`1)">
            Constructs the data
        </member>
        <member name="M:ImTools.ImHashMapEntry`2.#ctor(System.Int32,`0)">
            Constructs the data with the default value
        </member>
        <member name="M:ImTools.ImHashMapEntry`2.ToString">
            <summary>Outputs the brief tree info - mostly for debugging purposes</summary>
        </member>
        <member name="T:ImTools.ImHashMapConflicts`2">
            Stores ALL the data in `Conflicts` array, the fields except the `hash` are just fillers.
            This way we preserve the once created `ImHashMapData` so that client can hold the reference to it and update the Value if needed.
        </member>
        <member name="F:ImTools.ImHashMapConflicts`2.Conflicts">
            Conflicted data
        </member>
        <member name="M:ImTools.ImHashMapConflicts`2.#ctor(System.Int32,ImTools.ImHashMapEntry{`0,`1}[])">
            <inheritdoc />
        </member>
        <member name="T:ImTools.ImHashMap`2">
            Immutable http://en.wikipedia.org/wiki/AVL_tree 
            where node key is the hash code of <typeparamref name="K"/>
        </member>
        <member name="F:ImTools.ImHashMap`2.Empty">
            Empty map to start with.
        </member>
        <member name="P:ImTools.ImHashMap`2.Hash">
            <summary>Calculated key hash.</summary>
        </member>
        <member name="P:ImTools.ImHashMap`2.Key">
            <summary>Key of type K that should support <see cref="M:System.Object.Equals(System.Object)"/> and <see cref="M:System.Object.GetHashCode"/>.</summary>
        </member>
        <member name="P:ImTools.ImHashMap`2.Value">
            <summary>Value of any type V.</summary>
        </member>
        <member name="P:ImTools.ImHashMap`2.Conflicts">
            <summary>In case of <see cref="P:ImTools.ImHashMap`2.Hash"/> conflicts for different keys contains conflicted keys with their values.</summary>
        </member>
        <member name="F:ImTools.ImHashMap`2.Left">
            <summary>Left sub-tree/branch, or empty.</summary>
        </member>
        <member name="F:ImTools.ImHashMap`2.Right">
            <summary>Right sub-tree/branch, or empty.</summary>
        </member>
        <member name="F:ImTools.ImHashMap`2.Height">
            <summary>Height of longest sub-tree/branch plus 1. It is 0 for empty tree, and 1 for single node tree.</summary>
        </member>
        <member name="P:ImTools.ImHashMap`2.IsEmpty">
            <summary>Returns true if tree is empty.</summary>
        </member>
        <member name="F:ImTools.ImHashMap`2.Entry">
            <summary>The entry which is allocated once and can be used as a "fixed" reference to the Key and Value</summary>
        </member>
        <member name="M:ImTools.ImHashMap`2.#ctor(System.Int32,`0,`1)">
            Creates  leaf node
        </member>
        <member name="M:ImTools.ImHashMap`2.#ctor(System.Int32,`0)">
            Creates a leaf node with default value
        </member>
        <member name="M:ImTools.ImHashMap`2.#ctor(ImTools.ImHashMapEntry{`0,`1})">
            Creates a leaf node
        </member>
        <member name="M:ImTools.ImHashMap`2.#ctor(ImTools.ImHashMapEntry{`0,`1},ImTools.ImHashMap{`0,`1},ImTools.ImHashMap{`0,`1})">
            Creates the tree and calculates the height for you
        </member>
        <member name="M:ImTools.ImHashMap`2.#ctor(ImTools.ImHashMapEntry{`0,`1},ImTools.ImHashMap{`0,`1},ImTools.ImHashMap{`0,`1},System.Int32)">
            Creates the tree with the known height
        </member>
        <member name="M:ImTools.ImHashMap`2.ToString">
            <summary>Outputs the brief tree info - mostly for debugging purposes</summary>
        </member>
        <member name="M:ImTools.ImHashMap`2.AddOrUpdate(System.Int32,`0,`1)">
            <summary>Uses the user provided hash and adds and updates the tree with passed key-value. Returns a new tree.</summary>
        </member>
        <member name="M:ImTools.ImHashMap`2.AddOrUpdate(`0,`1)">
            Adds and updates the tree with passed key-value. Returns a new tree.
        </member>
        <member name="M:ImTools.ImHashMap`2.AddOrUpdate(System.Int32,`0,`1,ImTools.Update{`0,`1})">
            Uses the user provided hash and adds and updates the tree with passed key-value and the update function for the existing value. Returns a new tree.
        </member>
        <member name="M:ImTools.ImHashMap`2.AddOrUpdate(`0,`1,ImTools.Update{`0,`1})">
            Returns a new tree with added or updated key-value. Uses the provided <paramref name="update"/> for updating the existing value.
        </member>
        <member name="M:ImTools.ImHashMap`2.AddOrUpdate(`0,`1,ImTools.Update{`1})">
            Returns a new tree with added or updated key-value. Uses the provided <paramref name="update"/> for updating the existing value.
        </member>
        <member name="M:ImTools.ImHashMap`2.AddOrKeep(System.Int32,`0,`1)">
            Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        </member>
        <member name="M:ImTools.ImHashMap`2.AddOrKeep(`0,`1)">
            Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        </member>
        <member name="M:ImTools.ImHashMap`2.AddOrKeep(System.Int32,`0)">
            Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        </member>
        <member name="M:ImTools.ImHashMap`2.AddOrKeep(`0)">
            Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        </member>
        <member name="M:ImTools.ImHashMap`2.Update(System.Int32,`0,`1,ImTools.Update{`0,`1})">
            Updates the map with the new value if key is found, otherwise returns the same unchanged map.
        </member>
        <member name="M:ImTools.ImHashMap`2.Update(`0,`1)">
            Updates the map with the new value if key is found, otherwise returns the same unchanged map.
        </member>
        <member name="M:ImTools.ImHashMap`2.Update(`0,`1,ImTools.Update{`1})">
            Updates the map with the new value if key is found, otherwise returns the same unchanged map.
        </member>
        <member name="M:ImTools.ImHashMap`2.UpdateToDefault(System.Int32,`0)">
            Updates the map with the Default (null for reference types) value if key is found, otherwise returns the same unchanged map.
        </member>
        <member name="M:ImTools.ImHashMap`2.Enumerate">
            <summary>
            Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
            The only difference is using fixed size array instead of stack for speed-up.
            </summary>
        </member>
        <member name="M:ImTools.ImHashMap`2.Fold``1(``0,System.Func{ImTools.ImHashMapEntry{`0,`1},``0,``0},ImTools.ImHashMap{`0,`1}[])">
            <summary>
            Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
            The only difference is using fixed size array instead of stack for speed-up.
            Note: By passing <paramref name="parentsStack"/> you may reuse the stack array between different method calls,
            but it should be at least <see cref="F:ImTools.ImHashMap`2.Height"/> length. The contents of array are not important.
            </summary>
        </member>
        <member name="M:ImTools.ImHashMap`2.Fold``1(``0,System.Func{ImTools.ImHashMapEntry{`0,`1},System.Int32,``0,``0},ImTools.ImHashMap{`0,`1}[])">
            <summary>
            Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
            The only difference is using fixed size array instead of stack for speed-up.
            Note: By passing <paramref name="parentsStack"/> you may reuse the stack array between different method calls,
            but it should be at least <see cref="F:ImTools.ImHashMap`2.Height"/> length. The contents of array are not important.
            </summary>
        </member>
        <member name="M:ImTools.ImHashMap`2.Visit``1(``0,System.Action{ImTools.ImHashMapEntry{`0,`1},``0},ImTools.ImHashMap{`0,`1}[])">
            <summary>
            Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
            The only difference is using fixed size array instead of stack for speed-up.
            Note: By passing <paramref name="parentsStack"/> you may reuse the stack array between different method calls,
            but it should be at least <see cref="F:ImTools.ImHashMap`2.Height"/> length. The contents of array are not important.
            </summary>
        </member>
        <member name="M:ImTools.ImHashMap`2.Visit(System.Action{ImTools.ImHashMapEntry{`0,`1}},ImTools.ImHashMap{`0,`1}[])">
            <summary>
            Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
            The only difference is using fixed size array instead of stack for speed-up.
            Note: By passing <paramref name="parentsStack"/> you may reuse the stack array between different method calls,
            but it should be at least <see cref="F:ImTools.ImHashMap`2.Height"/> length. The contents of array are not important.
            </summary>
        </member>
        <member name="M:ImTools.ImHashMap`2.FindFirstOrDefault(System.Func{ImTools.ImHashMapEntry{`0,`1},System.Boolean},ImTools.ImHashMap{`0,`1}[])">
            <summary> Finds the first entry matching the condition, returns `null` if not found </summary>
        </member>
        <member name="M:ImTools.ImHashMap`2.Remove(System.Int32,`0)">
            Removes or updates value for specified key, or does nothing if the key is not found (returns the unchanged map)
            Based on Eric Lippert http://blogs.msdn.com/b/ericlippert/archive/2008/01/21/immutability-in-c-part-nine-academic-plus-my-avl-tree-implementation.aspx
        </member>
        <member name="M:ImTools.ImHashMap`2.Remove(`0)">
            Removes or updates value for specified key, or does nothing if the key is not found (returns the unchanged map)
            Based on Eric Lippert http://blogs.msdn.com/b/ericlippert/archive/2008/01/21/immutability-in-c-part-nine-academic-plus-my-avl-tree-implementation.aspx
        </member>
        <member name="M:ImTools.ImHashMap`2.ContainsConflictedData(`0)">
            <summary> Searches for the key in the conflicts and returns true if found </summary>
        </member>
        <member name="M:ImTools.ImHashMap`2.GetConflictedEntryOrDefault(`0)">
            <summary> Searches for the key in the node conflicts </summary>
        </member>
        <member name="M:ImTools.ImHashMap`2.GetConflictedValueOrDefault(`0,`1)">
            Searches for the key in the node conflicts
        </member>
        <member name="M:ImTools.ImHashMap`2.TryFindConflictedValue(`0,`1@)">
            Searches for the key in the node conflicts
        </member>
        <member name="T:ImTools.ImHashMap">
            ImHashMap methods for faster performance
        </member>
        <member name="M:ImTools.ImHashMap.Contains``2(ImTools.ImHashMap{``0,``1},System.Int32,``0)">
            <summary> Looks for key in a tree and returns `true` if found. </summary>
        </member>
        <member name="M:ImTools.ImHashMap.Contains``2(ImTools.ImHashMap{``0,``1},``0)">
            <summary> Looks for key in a tree and returns `true` if found. </summary>
        </member>
        <member name="M:ImTools.ImHashMap.GetEntryOrDefault``2(ImTools.ImHashMap{``0,``1},System.Int32,``0)">
            Looks for key in a tree and returns the Data object if found or `null` otherwise.
        </member>
        <member name="M:ImTools.ImHashMap.GetEntryOrDefault``2(ImTools.ImHashMap{``0,``1},``0)">
            <summary> Looks for key in a tree and returns the Data object if found or `null` otherwise. </summary> 
        </member>
        <member name="M:ImTools.ImHashMap.GetValueOrDefault``2(ImTools.ImHashMap{``0,``1},``0,``1)">
            Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.
        </member>
        <member name="M:ImTools.ImHashMap.GetValueOrDefault``2(ImTools.ImHashMap{``0,``1},System.Int32,``0,``1)">
            Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.
        </member>
        <member name="M:ImTools.ImHashMap.GetValueOrDefault``1(ImTools.ImHashMap{System.Type,``0},System.Type,``0)">
            Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.
        </member>
        <member name="M:ImTools.ImHashMap.GetValueOrDefault``1(ImTools.ImHashMap{System.Type,``0},System.Int32,System.Type,``0)">
            Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.
        </member>
        <member name="M:ImTools.ImHashMap.TryFind``2(ImTools.ImHashMap{``0,``1},``0,``1@)">
            Returns true if key is found and sets the value.
        </member>
        <member name="M:ImTools.ImHashMap.TryFind``2(ImTools.ImHashMap{``0,``1},System.Int32,``0,``1@)">
            Returns true if key is found and sets the value.
        </member>
        <member name="M:ImTools.ImHashMap.TryFind``1(ImTools.ImHashMap{System.Type,``0},System.Type,``0@)">
            Returns true if key is found and the result value.
        </member>
        <member name="M:ImTools.ImHashMap.TryFind``1(ImTools.ImHashMap{System.Type,``0},System.Int32,System.Type,``0@)">
            Returns true if hash and key are found and the result value, or the false otherwise
        </member>
        <member name="M:ImTools.ImHashMap.AddOrUpdate``1(ImTools.ImHashMap{System.Type,``0},System.Type,``0)">
            <summary>Uses `RuntimeHelpers.GetHashCode()`</summary>
        </member>
        <member name="T:ImTools.ImHashMapSlots">
            The array of ImHashMap slots where the key first bits are used for FAST slot location
            and the slot is the reference to ImHashMap that can be swapped with its updated value
        </member>
        <member name="F:ImTools.ImHashMapSlots.SLOT_COUNT_POWER_OF_TWO">
            Default number of slots
        </member>
        <member name="F:ImTools.ImHashMapSlots.HASH_MASK_TO_FIND_SLOT">
            The default mask to partition the key to the target slot
        </member>
        <member name="M:ImTools.ImHashMapSlots.CreateWithEmpty``2(System.Int32)">
            Creates the array with the empty slots
        </member>
        <member name="M:ImTools.ImHashMapSlots.AddOrUpdate``2(ImTools.ImHashMap{``0,``1}[],System.Int32,``0,``1,System.Int32)">
            Returns a new tree with added or updated value for specified key.
        </member>
        <member name="M:ImTools.ImHashMapSlots.AddOrUpdate``2(ImTools.ImHashMap{``0,``1}[],``0,``1,System.Int32)">
            Returns a new tree with added or updated value for specified key.
        </member>
        <member name="M:ImTools.ImHashMapSlots.RefAddOrUpdateSlot``2(ImTools.ImHashMap{``0,``1}@,System.Int32,``0,``1)">
            Updates the ref to the slot with the new version - retry if the someone changed the slot in between
        </member>
        <member name="M:ImTools.ImHashMapSlots.AddOrUpdate``2(ImTools.ImHashMap{``0,``1}[],System.Int32,``0,``1,ImTools.Update{``0,``1},System.Int32)">
            Updates the value with help of `updateValue` function
        </member>
        <member name="M:ImTools.ImHashMapSlots.AddOrUpdate``2(ImTools.ImHashMap{``0,``1}[],``0,``1,ImTools.Update{``0,``1},System.Int32)">
            Updates the value with help of `updateValue` function
        </member>
        <member name="M:ImTools.ImHashMapSlots.RefAddOrUpdateSlot``2(ImTools.ImHashMap{``0,``1}@,System.Int32,``0,``1,ImTools.Update{``0,``1})">
            Update the ref to the slot with the new version - retry if the someone changed the slot in between
        </member>
        <member name="M:ImTools.ImHashMapSlots.AddOrKeep``2(ImTools.ImHashMap{``0,``1}[],System.Int32,``0,``1,System.Int32)">
            Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        </member>
        <member name="M:ImTools.ImHashMapSlots.AddOrKeep``2(ImTools.ImHashMap{``0,``1}[],``0,``1,System.Int32)">
            Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        </member>
        <member name="M:ImTools.ImHashMapSlots.RefAddOrKeepSlot``2(ImTools.ImHashMap{``0,``1}@,System.Int32,``0,``1)">
            Update the ref to the slot with the new version - retry if the someone changed the slot in between
        </member>
        <member name="M:ImTools.ImHashMapSlots.Update``2(ImTools.ImHashMap{``0,``1}[],System.Int32,``0,``1,System.Int32)">
            Updates the specified slot or does not change it
        </member>
        <member name="M:ImTools.ImHashMapSlots.Update``2(ImTools.ImHashMap{``0,``1}[],``0,``1,System.Int32)">
            Updates the specified slot or does not change it
        </member>
        <member name="M:ImTools.ImHashMapSlots.RefUpdateSlot``2(ImTools.ImHashMap{``0,``1}@,System.Int32,``0,``1)">
            Update the ref to the slot with the new version - retry if the someone changed the slot in between
        </member>
        <member name="M:ImTools.ImHashMapSlots.Fold``3(ImTools.ImHashMap{``0,``1}[],``2,System.Func{ImTools.ImHashMapEntry{``0,``1},``2,``2})">
            Returns all map tree nodes without the order
        </member>
    </members>
</doc>
